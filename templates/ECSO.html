<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Simulador de Examen - Ayuda con Google IA</title>
    <style>
        body { font-family: 'Segoe UI', Tahoma, sans-serif; background: #f0f4f8; display: flex; justify-content: center; padding: 20px; }
        #quiz-container { background: white; padding: 30px; border-radius: 15px; box-shadow: 0 10px 25px rgba(0,0,0,0.1); width: 100%; max-width: 850px; }
        .stats { display: flex; justify-content: space-between; font-weight: bold; margin-bottom: 20px; font-size: 1.1rem; border-bottom: 2px solid #edf2f7; padding-bottom: 10px; }
        .question-box { background: #ffffff; border: 2px solid #e2e8f0; padding: 20px; border-radius: 12px; margin-bottom: 20px; position: relative; }
        .question-text { margin-right: 55px; line-height: 1.5; white-space: pre-wrap; }
        .code-block { margin-top: 12px; background: #0f172a; color: #e2e8f0; padding: 12px; border-radius: 8px; font-family: 'Cascadia Code', Consolas, 'Courier New', monospace; font-size: 0.95rem; white-space: pre; overflow-x: auto; }
        .google-ask { position: absolute; top: 15px; right: 15px; background: #f0f7ff; border: 1px solid #c3dafe; border-radius: 50%; width: 45px; height: 45px; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 24px; transition: 0.3s; text-decoration: none; }
        .google-ask:hover { background: #ebf4ff; transform: scale(1.1); border-color: #3182ce; }
        .option { display: block; width: 100%; padding: 15px; margin: 10px 0; border: 2px solid #e2e8f0; border-radius: 10px; cursor: pointer; text-align: left; background: #fff; font-size: 1rem; transition: 0.2s; }
        .option:hover { background: #f7fafc; border-color: #4299e1; }
        .correct { background: #c6f6d5 !important; border-color: #38a169 !important; color: #22543d; font-weight: bold; }
        .wrong { background: #fed7d7 !important; border-color: #e53e3e !important; color: #742a2a; }
        .ai-hint-btn { margin-top: 12px; padding: 10px 18px; background: #1e40af; color: #fff; border: none; border-radius: 8px; cursor: pointer; font-weight: bold; }
        .ai-hint-btn:hover { background: #1e3a8a; }
        .ai-hint-box { margin-top: 10px; background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 10px; padding: 12px; color: #1f2937; font-size: 0.95rem; display: none; }
        .ai-hint-box.loading { display: block; color: #64748b; font-style: italic; }
        .ai-hint-box.visible { display: block; }
        
        .nav-buttons { display: flex; justify-content: space-between; gap: 12px; margin-top: 20px; }
        .nav-btn { padding: 12px 30px; background: #3182ce; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: bold; }
        .nav-btn:hover { background: #2b6cb0; }
        .nav-btn:disabled { background: #a0aec0; cursor: not-allowed; }

        .setup-actions { display: flex; justify-content: center; gap: 12px; flex-wrap: wrap; margin-top: 20px; }
        .setup-btn { padding: 12px 24px; background: #3182ce; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: bold; }
        .setup-btn:hover { background: #2b6cb0; }
        .setup-btn:disabled { background: #a0aec0; cursor: not-allowed; }

        .quiz-actions { display: flex; justify-content: flex-end; gap: 12px; margin-bottom: 12px; }
        .action-btn { padding: 8px 16px; border: 2px solid #cbd5e0; background: #fff; border-radius: 8px; cursor: pointer; font-weight: bold; }
        .action-btn:hover { background: #f7fafc; border-color: #a0aec0; }
        .action-btn.danger { color: #c53030; border-color: #feb2b2; background: #fff5f5; }
        .action-btn.danger:hover { background: #fed7d7; border-color: #f56565; }

        @media (max-width: 900px) {
            body { padding: 14px; }
            #quiz-container { padding: 22px; }
            .stats { flex-direction: column; gap: 10px; align-items: flex-start; }
            .quiz-actions { justify-content: flex-start; flex-wrap: wrap; }
            .question-box { padding: 16px; }
            .question-text { margin-right: 50px; }
            .google-ask { width: 40px; height: 40px; font-size: 20px; }
            .option { padding: 12px; font-size: 0.98rem; }
            .nav-btn { padding: 12px 22px; }
        }

        @media (max-width: 600px) {
            body { padding: 10px; }
            #quiz-container { padding: 18px; border-radius: 12px; }
            .stats { font-size: 1rem; }
            .question-text { margin-right: 0; }
            .google-ask { position: static; margin-top: 10px; align-self: flex-start; }
            .question-box { display: flex; flex-direction: column; gap: 10px; }
            .option { padding: 12px; font-size: 0.95rem; }
            .nav-buttons { flex-direction: column; }
            .nav-btn { width: 100%; }
            .setup-actions { flex-direction: column; }
            .setup-btn { width: 100%; }
            .quiz-actions { flex-direction: column; align-items: stretch; }
            .action-btn { width: 100%; }
            .ai-hint-btn { width: 100%; }
        }
    </style>
</head>
<body>

<div id="quiz-container">
    <div id="setup" style="text-align:center; padding: 40px;">
        <h2>游닄 Preparador de Examen Din치mico</h2>
        <p>Selecciona el bloque de preguntas para comenzar.</p>
        <div class="setup-actions">
            <button id="load-ec" class="setup-btn">Cargar Estructura de computadores</button>
            <button id="load-so" class="setup-btn">Cargar Sistemas Operativos</button>
        </div>
    </div>

    <div id="quiz-game" style="display:none;">
        <div class="stats">
            <span>Pregunta: <span id="q-idx">0</span> / <span id="q-total">0</span></span>
            <div>
                <span style="color:#38a169">Aciertos: <span id="hits">0</span></span> | 
                <span style="color:#e53e3e">Fallos: <span id="miss">0</span></span>
            </div>

        <div class="quiz-actions">
            <button id="exit-btn" class="action-btn">Salir</button>
            <button id="restart-btn" class="action-btn danger">Recomenzar</button>
        </div>

        </div>
        
        <div class="question-box">
            <b>
            <div id="question-text" class="question-text"></div>
            </b>
            <a id="ia-btn" href="#" target="_blank" class="google-ask" title="Explicaci칩n con Google IA">游뱄</a>
            <div> 
                <div id="hint-box" class="ai-hint-box"></div>
            </div>
        </div>

        <div id="options-container"></div>
        <div class="nav-buttons">
            <button id="prev-btn" class="nav-btn" onclick="prevQuestion()">Anterior</button>
            <button id="next-btn" class="nav-btn" onclick="nextQuestion()">Siguiente</button>
        </div>
    </div>
</div>



<script>
    const preguntasEstructura = [
  {
    "q": "A la hora de ejecutarse un programa, 쯤u칠 fases sigue?",
    "options": [
      "Lectura de la instrucci칩n, carga inicial, ejecuci칩n de la instrucci칩n e incremento del PC.",
      "Carga inicial, lectura de la instrucci칩n, ejecuci칩n de la instrucci칩n, incremento del PC y repetici칩n de ciclo.",
      "Lectura de la instrucci칩n, carga inicial,, ejecuci칩n de la instrucci칩n, incremento del PC y repetici칩n de ciclo.",
      "Lectura de la instrucci칩n, ejecuci칩n de la instrucci칩n, incremento del PC y repetici칩n de ciclo."
    ],
    "correctIndex": 1
  },
  {
    "q": "Al respecto del procesador MIPS32:",
    "options": [
      "Para sumar dos posiciones de memoria no hace falta cargarlas en registros.",
      "Tiene un ancho de palabra de 2 bytes.",
      "El modo kernel es el modo de funcionamiento con m치s permisos sobre el hardware.",
      "Trabaja con c칩digos m치s complejos por tener m치s instrucciones."
    ],
    "correctIndex": 2
  },
  {
    "q": "Como estudiantes reci칠n graduados, en nuestro primer trabajo, nos piden dise침ar una computadora para un sistema empotrado, 쯤u칠 tipo de arquitectura recomendar칤as utilizar?",
    "options": [
      "Un Macintosh.",
      "Harvard.",
      "Von Neumann.",
      "Un servidor Windows."
    ],
    "correctIndex": 1
  },
  {
    "q": "Con la aplicaci칩n de la Ley Amdahl, podemos asegurar que",
    "options": [
      "M치s procesadores no implica m치s rendimiento.",
      "Hay que evitar la programaci칩n secuencial.",
      "Ninguna de las respuestas es v치lida.",
      "No existen problemas de tama침o de memoria."
    ],
    "correctIndex": 0
  },
  {
    "q": "DMA (Direct Memory Access) permite:",
    "options": [
      "Que la CPU haga todo el trabajo de E/S.",
      "Que los perif칠ricos accedan a la memoria principal sin intervenci칩n constante de la CPU.",
      "Que la memoria sea m치s r치pida.",
      "Que no se use memoria RAM."
    ],
    "correctIndex": 1
  },
  {
    "q": "El CP (contador de programa), 쯔 d칩nde apunta?",
    "options": [
      "A la siguiente instrucci칩n.",
      "A la instrucci칩n en curso.",
      "A la instrucci칩n previamente ejecutada.",
      "Ninguna de las anteriores."
    ],
    "correctIndex": 0
  },
  {
    "q": "El ancho de banda de memoria es:",
    "options": [
      "El tiempo de acceso.",
      "La cantidad de datos que pueden transferirse por unidad de tiempo.",
      "El n칰mero de pines del m칩dulo de memoria.",
      "La capacidad total de almacenamiento."
    ],
    "correctIndex": 1
  },
  {
    "q": "El bus de direcciones:",
    "options": [
      "Transmite los datos entre la CPU y la memoria.",
      "Indica la direcci칩n de memoria o dispositivo de E/S con el que la CPU quiere comunicarse.",
      "Transmite las se침ales de control.",
      "Es bidireccional."
    ],
    "correctIndex": 1
  },
  {
    "q": "El chipset es:",
    "options": [
      "Un conjunto de chips que gestionan el flujo de datos entre los componentes de la placa base.",
      "El ventilador del procesador.",
      "La fuente de alimentaci칩n.",
      "El disco duro."
    ],
    "correctIndex": 0
  },
  {
    "q": "El ciclo de instrucci칩n comprende las fases de:",
    "options": [
      "B칰squeda y Ejecuci칩n.",
      "Lectura y Escritura.",
      "Entrada y Salida.",
      "Compilaci칩n y Enlace."
    ],
    "correctIndex": 0
  },
  {
    "q": "El c칩digo ASCII se utiliza para:",
    "options": [
      "Representar n칰meros en coma flotante.",
      "Representar caracteres alfanum칠ricos.",
      "Comprimir datos.",
      "Encriptar informaci칩n."
    ],
    "correctIndex": 1
  },
  {
    "q": "El c칩digo m치quina es:",
    "options": [
      "Un lenguaje de alto nivel.",
      "El lenguaje que entiende directamente el hardware de la CPU.",
      "Un lenguaje de script.",
      "Un lenguaje ensamblador."
    ],
    "correctIndex": 1
  },
  {
    "q": "El direccionamiento directo significa que:",
    "options": [
      "La instrucci칩n contiene la direcci칩n de memoria del operando.",
      "El operando est치 en un registro.",
      "Se usa un puntero.",
      "Se usa una pila."
    ],
    "correctIndex": 0
  },
  {
    "q": "El direccionamiento indirecto usa:",
    "options": [
      "Una direcci칩n que apunta a otra direcci칩n donde est치 el dato.",
      "El dato directamente.",
      "Un registro como 칤ndice.",
      "Ninguna de las anteriores."
    ],
    "correctIndex": 0
  },
  {
    "q": "El direccionamiento inmediato significa que:",
    "options": [
      "El operando est치 en un registro.",
      "El operando es una constante incluida en la propia instrucci칩n.",
      "La direcci칩n del operando est치 en memoria.",
      "La direcci칩n del operando es relativa al PC."
    ],
    "correctIndex": 1
  },
  {
    "q": "El formato complemento a 2 se utiliza para:",
    "options": [
      "Representar caracteres.",
      "Representar n칰meros enteros con signo.",
      "Representar im치genes.",
      "Representar instrucciones."
    ],
    "correctIndex": 1
  },
  {
    "q": "El lenguaje ensamblador:",
    "options": [
      "Es poco parecido entre procesadores distintos, aunque depende de la arquitectura.",
      "Es lo mismo que el c칩digo m치quina.",
      "Se llama de bajo nivel porque est치 m치s cerca del hardware.",
      "Se usa a menudo en la programaci칩n corriente."
    ],
    "correctIndex": 2
  },
  {
    "q": "El lenguaje m치quina ...",
    "options": [
      "Ninguna de las otras respuestas.",
      "Es un lenguaje de bajo nivel.",
      "Es un lenguaje de muy alto nivel.",
      "Es un lenguaje de alto nivel."
    ],
    "correctIndex": 1
  },
  {
    "q": "El nivel L1 de cach칠 es:",
    "options": [
      "El m치s grande y lento.",
      "El m치s peque침o y r치pido, integrado en el n칰cleo.",
      "Externo al procesador.",
      "Memoria virtual."
    ],
    "correctIndex": 1
  },
  {
    "q": "El pipelining (segmentaci칩n) permite:",
    "options": [
      "Ejecutar m칰ltiples instrucciones simult치neamente en diferentes etapas.",
      "Aumentar el tama침o de la memoria.",
      "Reducir la frecuencia de reloj.",
      "Eliminar las interrupciones."
    ],
    "correctIndex": 0
  },
  {
    "q": "El principio de localidad espacial dice que:",
    "options": [
      "Si se accede a una direcci칩n, es probable que se acceda a las cercanas pronto.",
      "Si se accede a un dato, se volver치 a acceder al mismo pronto.",
      "La memoria debe estar en el espacio.",
      "Los datos se guardan aleatoriamente."
    ],
    "correctIndex": 0
  },
  {
    "q": "El principio de localidad temporal dice que:",
    "options": [
      "Si se accede a un dato, es probable que se vuelva a acceder al mismo en un futuro pr칩ximo.",
      "Los datos cercanos se usar치n pronto.",
      "El tiempo de acceso es constante.",
      "La memoria es vol치til."
    ],
    "correctIndex": 0
  },
  {
    "q": "El programa siguiente verifica si un n칰mero es mayor a una constante y almacena diferentes valores en funci칩n de esa constante. 쯈u칠 constante es?",
    "code": ".data\nx: .word 7\nresult: .word 0\n.text\nmain:\n  lw $t0, x\n  li $t1, 5\n  blt $t0, $t1, else_block\nif_block:\n  li $t2, 1\n  sw $t2, result\n  j end_if\nelse_block:\n  li $t2, 0\n  sw $t2, result\nend_if:\n  li $v0, 10\n  syscall",
    "options": [
      "3",
      "5",
      "7",
      "10"
    ],
    "correctIndex": 1
  },
  {
    "q": "El registro IR (Instruction Register) almacena:",
    "options": [
      "La direcci칩n de la siguiente instrucci칩n.",
      "La instrucci칩n que se est치 decodificando o ejecutando actualmente.",
      "El resultado de la ALU.",
      "El estado de las banderas."
    ],
    "correctIndex": 1
  },
  {
    "q": "El registro PC (Program Counter) contiene:",
    "options": [
      "La instrucci칩n que se est치 ejecutando.",
      "La direcci칩n de la siguiente instrucci칩n a ejecutar.",
      "El estado del procesador.",
      "El resultado de la 칰ltima operaci칩n."
    ],
    "correctIndex": 1
  },
  {
    "q": "El registro de instrucci칩n ...",
    "options": [
      "Contiene los valores sobre los que se va a ejecutar la instrucci칩n.",
      "Ninguna de las otras respuestas.",
      "Contiene la siguiente instrucci칩n a ejecutar en c칩digo ensamblador.",
      "Contiene la actual instrucci칩n a ejecutar en c칩digo ensamblador."
    ],
    "correctIndex": 1
  },
  {
    "q": "El sistema binario utiliza los d칤gitos:",
    "options": [
      "0 a 9.",
      "0 y 1.",
      "0 a 7.",
      "0 a F."
    ],
    "correctIndex": 1
  },
  {
    "q": "El stack (pila) se utiliza para:",
    "options": [
      "Almacenar variables locales y direcciones de retorno de subrutinas.",
      "Almacenar el c칩digo del programa.",
      "Almacenar archivos grandes.",
      "La memoria de v칤deo."
    ],
    "correctIndex": 0
  },
  {
    "q": "El tiempo de acceso medio a memoria depende de:",
    "options": [
      "La tasa de aciertos (hit rate) y los tiempos de acceso de cach칠 y memoria principal.",
      "Solo del tama침o de la RAM.",
      "Solo de la velocidad del disco.",
      "Del sistema operativo."
    ],
    "correctIndex": 0
  },
  {
    "q": "En el formato de representaci칩n en coma flotante IEEE 754 de simple precisi칩n:",
    "options": [
      "El exponente tiene 8 bits y la mantisa 23 bits.",
      "El exponente tiene 11 bits y la mantisa 52 bits.",
      "El exponente tiene 8 bits y la mantisa 24 bits.",
      "El exponente tiene 11 bits y la mantisa 53 bits."
    ],
    "correctIndex": 0
  },
  {
    "q": "En el sistema de representaci칩n binaria, para representar n칰meros negativos se suele usar ...",
    "options": [
      "Complemento a dos.",
      "Signo y magnitud.",
      "Complemento a uno.",
      "Exceso a 2 elevado a n."
    ],
    "correctIndex": 0
  },
  {
    "q": "En la unidad de control:",
    "options": [
      "Activa unos y otros bloques de la ruta de datos dependiendo de la fase de ejecuci칩n en la que estemos.",
      "Los datos fluyen dentro de sus componentes.",
      "Est치 basado en una m치quina de estados Mealy.",
      "Es un circuito combinacional con muchas entradas."
    ],
    "correctIndex": 0
  },
  {
    "q": "En un computador con jerarqu칤a de memoria, la memoria virtual permite ...",
    "options": [
      "Utilizar almacenamiento secundario como si fuera parte de la memoria principal.",
      "Aumentar la velocidad de la cach칠.",
      "Reducir el n칰mero de registros en la CPU.",
      "Eliminar la necesidad de RAM f칤sica."
    ],
    "correctIndex": 0
  },
  {
    "q": "En un sistema de numeraci칩n posicional, el valor de un d칤gito depende de:",
    "options": [
      "Su posici칩n dentro del n칰mero.",
      "Su valor absoluto solamente.",
      "El n칰mero de d칤gitos totales.",
      "La base del sistema 칰nicamente."
    ],
    "correctIndex": 0
  },
  {
    "q": "En una memoria:",
    "options": [
      "Tenemos tantos bits almacenados como 2 elevado al n칰mero de l칤neas.",
      "La cantidad total de datos almacenada es potencia de 2.",
      "En cada posici칩n de memoria hay almacenado un dato 칰til.",
      "El n칰mero de posiciones de memoria es 2 elevado al n칰mero de bits de su entrada de datos."
    ],
    "correctIndex": 1
  },
  {
    "q": "Es Harvard si las instrucciones pueden tener distinto tama침o que los datos.",
    "options": [
      "Es Harvard si las instrucciones no pueden tener distinto tama침o que los datos.",
      "Es Harvard si las instrucciones pueden tener distinto tama침o que los datos.",
      "Es von Neumann si el bus de datos y el de instrucciones son bidireccionales.",
      "Es Harvard si usamos el mismo bus para control que para datos."
    ],
    "correctIndex": 1
  },
  {
    "q": "Es muy parecido entre procesadores distintos, aunque depende de la arquitectura.",
    "options": [
      "Es muy parecido entre procesadores distintos, aunque depende de la arquitectura.",
      "Permite programar un computador sin preocuparse de su arquitectura.",
      "Es m치s f치cil de programar, por eso se llama de bajo nivel.",
      "Es muy frecuentemente utilizado cuando no nos importa la eficiencia del c칩digo."
    ],
    "correctIndex": 0
  },
  {
    "q": "Indica cu치l de las siguientes afirmaciones es correcta:",
    "options": [
      "Un computador Harvard tiene un bus de datos compartido con instrucciones.",
      "Un computador von Neumann tiene un bus de datos separado del de instrucciones.",
      "Un computador Harvard tiene memoria de datos separada de la de instrucciones.",
      "Ninguna de las otras respuestas."
    ],
    "correctIndex": 2
  },
  {
    "q": "Indica la respuesta verdadera:",
    "options": [
      "El ENIAC fue el primer computador de la historia.",
      "El 치baco es el primer computador de la historia.",
      "La m치quina anal칤tica de Babbage fue el primer computador de la historia.",
      "Ninguna de las otras respuestas."
    ],
    "correctIndex": 3
  },
  {
    "q": "La ALU (Arithmetic Logic Unit) se encarga de:",
    "options": [
      "Controlar el flujo de datos.",
      "Realizar operaciones aritm칠ticas y l칩gicas.",
      "Almacenar instrucciones.",
      "Gestionar la memoria."
    ],
    "correctIndex": 1
  },
  {
    "q": "La ALU, es una parte de:",
    "options": [
      "La memoria.",
      "El bus de operaciones.",
      "La CPU.",
      "El multiplexor de entrada."
    ],
    "correctIndex": 2
  },
  {
    "q": "La ALU:",
    "options": [
      "Solamente opera con registros.",
      "Trabaja directamente con la memoria.",
      "La entrada zero pone a cero la ALU.",
      "Los bits del c칩digo de operaci칩n de la instrucci칩n le indican directamente qu칠 operaci칩n debe realizar."
    ],
    "correctIndex": 0
  },
  {
    "q": "La BIOS es:",
    "options": [
      "Un sistema operativo completo.",
      "Un firmware que inicializa el hardware durante el arranque.",
      "Un programa de edici칩n de texto.",
      "Un virus inform치tico."
    ],
    "correctIndex": 1
  },
  {
    "q": "La arquitectura CISC se caracteriza por:",
    "options": [
      "Tener un conjunto reducido de instrucciones simples.",
      "Tener un conjunto amplio de instrucciones complejas.",
      "No utilizar memoria cach칠.",
      "Ser m치s r치pida que RISC en todos los casos."
    ],
    "correctIndex": 1
  },
  {
    "q": "La arquitectura RISC se caracteriza por:",
    "options": [
      "Instrucciones de longitud variable.",
      "Instrucciones simples y de longitud fija.",
      "Mayor complejidad en el hardware que CISC.",
      "Menor n칰mero de registros."
    ],
    "correctIndex": 1
  },
  {
    "q": "La frecuencia de reloj de una CPU se mide en:",
    "options": [
      "Bytes.",
      "Herzios (Hz).",
      "Julios.",
      "Bits por segundo."
    ],
    "correctIndex": 1
  },
  {
    "q": "La jerarqu칤a de memoria busca:",
    "options": [
      "Maximizar la capacidad y minimizar el coste y tiempo de acceso.",
      "Minimizar la capacidad y maximizar la velocidad.",
      "Usar solo memoria cach칠.",
      "Usar solo discos duros."
    ],
    "correctIndex": 0
  },
  {
    "q": "La latencia de memoria es:",
    "options": [
      "La cantidad de datos transferidos por segundo.",
      "El tiempo que transcurre desde que se solicita un dato hasta que se recibe.",
      "El tama침o de la memoria.",
      "La frecuencia de reloj de la memoria."
    ],
    "correctIndex": 1
  },
  {
    "q": "La ley de Moore establece que:",
    "options": [
      "El n칰mero de transistores en un microprocesador se duplica cada 18-24 meses.",
      "La velocidad de los procesadores se duplica cada 18-24 meses.",
      "El coste de los transistores se duplica cada 18-24 meses.",
      "El consumo de energ칤a se reduce a la mitad cada 18-24 meses."
    ],
    "correctIndex": 0
  },
  {
    "q": "La memoria DRAM necesita refresco peri칩dico de datos:",
    "options": [
      "Verdadero",
      "Falso"
    ],
    "correctIndex": 0
  },
  {
    "q": "La memoria ROM es:",
    "options": [
      "Vol치til y de lectura/escritura.",
      "No vol치til y de solo lectura.",
      "Vol치til y de solo lectura.",
      "No vol치til y de lectura/escritura."
    ],
    "correctIndex": 1
  },
  {
    "q": "La memoria SRAM es m치s r치pida pero m치s cara que la DRAM:",
    "options": [
      "Verdadero",
      "Falso"
    ],
    "correctIndex": 0
  },
  {
    "q": "La memoria cach칠 se utiliza para:",
    "options": [
      "Aumentar la capacidad de almacenamiento del disco duro.",
      "Reducir el tiempo de acceso a la memoria principal.",
      "Almacenar permanentemente los datos del usuario.",
      "Ninguna de las otras respuestas."
    ],
    "correctIndex": 1
  },
  {
    "q": "La memoria cach칠 suele ser de tipo:",
    "options": [
      "DRAM.",
      "SRAM.",
      "ROM.",
      "Flash."
    ],
    "correctIndex": 1
  },
  {
    "q": "La memoria principal se conecta a la CPU a trav칠s del:",
    "options": [
      "Bus del sistema (front-side bus o similar).",
      "Cable USB.",
      "Puerto serie.",
      "Red Wi-Fi."
    ],
    "correctIndex": 0
  },
  {
    "q": "La memoria virtual permite:",
    "options": [
      "Ejecutar programas m치s grandes que la memoria f칤sica disponible.",
      "Aumentar la velocidad del procesador.",
      "Almacenar datos en la nube.",
      "Reducir el consumo de energ칤a."
    ],
    "correctIndex": 0
  },
  {
    "q": "La operaci칩n POP en una pila:",
    "options": [
      "Saca el elemento de la cima.",
      "Introduce un elemento.",
      "Duplica el elemento.",
      "Invierte la pila."
    ],
    "correctIndex": 0
  },
  {
    "q": "La operaci칩n PUSH en una pila:",
    "options": [
      "Saca un elemento.",
      "Introduce un elemento en la cima.",
      "Lee el elemento de la cima sin sacarlo.",
      "Borra la pila."
    ],
    "correctIndex": 1
  },
  {
    "q": "La primera generaci칩n de computadores se caracteriz칩 por usar:",
    "options": [
      "Circuitos integrados.",
      "Tubos al vac칤o.",
      "Transistores.",
      "Chips."
    ],
    "correctIndex": 1
  },
  {
    "q": "La ruta de datos:",
    "options": [
      "Contiene registros.",
      "Solo alberga circuitos secuenciales.",
      "Es una m치quina moore.",
      "Mueve datos sin ayuda de ning칰n dispositvo."
    ],
    "correctIndex": 0
  },
  {
    "q": "La unidad de control genera:",
    "options": [
      "Se침ales de control para coordinar el hardware.",
      "Resultados aritm칠ticos.",
      "Direcciones de memoria.",
      "Interrupciones."
    ],
    "correctIndex": 0
  },
  {
    "q": "La unidad de control:",
    "options": [
      "Solo tiene circuitos combinacionales.",
      "No extrae informaci칩n de la ruta de datos.",
      "Puede cambiar el salto a su siguiente estado dependiendo de la ruta de datos.",
      "Trabaja sin reloj."
    ],
    "correctIndex": 2
  },
  {
    "q": "La unidad de medida utilizada para evaluar el rendimiento FLOPS indica:",
    "options": [
      "El n칰mero de accesos a memoria por segundo.",
      "El n칰mero de operaciones de coma flotante por segundo.",
      "La frecuencia de reloj (n칰mero de pulsos por segundo).",
      "El n칰mero de instrucciones por segundo."
    ],
    "correctIndex": 1
  },
  {
    "q": "La unidad m칤nima de informaci칩n que se puede representar en un ordenador es:",
    "options": [
      "El bit.",
      "El byte.",
      "La palabra.",
      "El nibble."
    ],
    "correctIndex": 0
  },
  {
    "q": "Las banderas (flags) de estado indican:",
    "options": [
      "El fabricante del procesador.",
      "Condiciones como cero, negativo, acarreo o desbordamiento tras una operaci칩n.",
      "La cantidad de memoria libre.",
      "La temperatura del procesador."
    ],
    "correctIndex": 1
  },
  {
    "q": "Los MFLOPS:",
    "options": [
      "Es un par치metro de rendimiento universal para todas las arquitecturas.",
      "A m치s MFLOPS m치s r치pido es un computador al ejecutar cualquier tarea.",
      "Est치 relacionados con el CPI.",
      "Miden todo tipo de operaciones."
    ],
    "correctIndex": 2
  },
  {
    "q": "Los multicomputadores tienen memoria compartida.",
    "options": [
      "Los multicomputadores tienen memoria compartida.",
      "Los procesadores segmentados requieren un gran ancho de banda en la memoria.",
      "Los procesadores vectoriales ahorran bucles de ejecuci칩n.",
      "Los procesadores vectoriales trabajan sobre vectores de resultados y datos."
    ],
    "correctIndex": 0
  },
  {
    "q": "Los registros de prop칩sito general sirven para:",
    "options": [
      "Almacenar datos temporales y operandos durante la ejecuci칩n.",
      "Controlar el flujo del programa 칰nicamente.",
      "Almacenar el sistema operativo.",
      "Conectar con perif칠ricos."
    ],
    "correctIndex": 0
  },
  {
    "q": "Los transistores pertenecen a la generaci칩n de computadores ...",
    "options": [
      "Tercera.",
      "Primera.",
      "Cuarta.",
      "Segunda."
    ],
    "correctIndex": 3
  },
  {
    "q": "Para acelerar el tiempo de ejecuci칩n en la suma de dos n칰meros de n bits ...",
    "options": [
      "Se puede usar un sumador con anticipaci칩n de acarreo.",
      "No se puede acelerar.",
      "Se usan n sumadores completos.",
      "Se usan n semisumadores."
    ],
    "correctIndex": 0
  },
  {
    "q": "Respecto a la arquitectura de un computador:",
    "options": [
      "Es von Neumann si el bus de datos y el de instrucciones es compartido.",
      "Es Harvard si los datos y el control comparten bus.",
      "Es Harvard si las instrucciones tienen el mismo tama침o que los datos y viajan por el mismo bus.",
      "Es Harvard si el ancho de palabra no es igual al tama침o de instrucci칩n."
    ],
    "correctIndex": 0
  },
  {
    "q": "Respecto a las arquitecturas que mejoran el rendimiento:",
    "options": [
      "Los multiprocesadores trabajan con total independencia entre si.",
      "Las segmentadas siempre son mejores.",
      "Los procesadores vectoriales son adecuados si las tareas tienen muchas iteraciones aritm칠ticas.",
      "Un procesador superescalar apenas tiene dependencias."
    ],
    "correctIndex": 2
  },
  {
    "q": "Respecto al CPI:",
    "options": [
      "A mayor CPI menos MIPS.",
      "El computador que tiene m치s ciclos por instrucci칩n es el m치s lento a la hora de ejecutar cualquier tarea.",
      "Depende de la frecuencia de reloj.",
      "Todas las instrucciones tienen los mismos ciclos."
    ],
    "correctIndex": 0
  },
  {
    "q": "Respecto al reloj de un procesador:",
    "options": [
      "Es dif칤cil comparar dos procesadores de dos arquitecturas distintas.",
      "El procesador con m치s frecuencia de reloj es el m치s r치pido del mercado en ejecutar todas las tareas.",
      "La se침al de reloj de un procesador es una sinusoidal entre 0 y 5 voltios.",
      "El procesador con m치s MIPS es el procesador m치s r치pido del mercado en ejecutar todas las tareas."
    ],
    "correctIndex": 0
  },
  {
    "q": "Se침ala la falsa:",
    "options": [
      "Los MIPS dependen de la frecuencia de reloj.",
      "Los MIPS son millones de instrucciones por segundo.",
      "La velocidad de reloj permite comparar arquitecturas",
      "Hay que promediar los ciclos de cada instrucci칩n para obtener el CPI medio."
    ],
    "correctIndex": 2
  },
  {
    "q": "Se침ala la verdadera al respecto del MIPS32:",
    "options": [
      "Es CISC.",
      "Direcciona los perif칠ricos como registros.",
      "Su arquitectura es de carga/almacenamiento.",
      "Trabaja indistintamente en cualquier modo."
    ],
    "correctIndex": 2
  },
  {
    "q": "Se침ala la verdadera:",
    "options": [
      "La CPU trabaja internamente en ensamblador.",
      "Si se introduce el c칩digo m치quina en una memoria, el procesador puede ejecutar ese programa directamente sin necesidad de compilador.",
      "Si se introduce un c칩digo en ensamblador en un compilador, obtenemos el c칩digo de alto nivel correspondiente.",
      "Un programa en ensamblador se escribe en c칩digo m치quina."
    ],
    "correctIndex": 1
  },
  {
    "q": "Se침alar el valor de $s1 tras el siguiente c칩digo",
    "code": "LI $S0, 10\nMOVE $S1, $ZERO\nETIQ1:\n  BGT $S1, $S0, END\n  ADDI $S1, $S1, 2\n  J ETIQ1\nEND:",
    "options": [
      "8",
      "10",
      "12",
      "14"
    ],
    "correctIndex": 2
  },
  {
    "q": "Si se introduce un c칩digo en ensamblador en un compilador, se obtiene un c칩digo m치quina ejecutable.",
    "options": [
      "Si se introduce un c칩digo en ensamblador en un compilador, se obtiene un c칩digo m치quina ejecutable.",
      "Un programa es un conjunto de instrucciones que se ejecutan secuencialmente tal cual est치n escritas en c칩digo m치quina.",
      "La CPU entiende directamente ensamblador porque est치 muy pr칩ximo al c칩digo m치quina.",
      "Si se introduce el c칩digo m치quina en un compilador, el ensamblador correspondiente puede ejecutar las instrucciones."
    ],
    "correctIndex": 0
  },
  {
    "q": "Sobre arquitectura de computadores:",
    "options": [
      "El paralelismo se detecta antes de la ejecuci칩n.",
      "Las m치quinas superescalares proporcionan compatibilidad a nivel de c칩digo objeto con las m치squinas escalares.",
      "Un procesador superescalar de grado m tiene un CPI de m.",
      "Los procesadores superescalares se utilizan en tareas intensivas de c치lculo"
    ],
    "correctIndex": 3
  },
  {
    "q": "Sobre el m칩dulo de E/S se침ala la falsa:",
    "options": [
      "Nunca almacena datos.",
      "Gestiona la comunicaci칩n con el perif칠rico.",
      "Realiza el control y temporizaci칩n para evitar p칠rdidas de informaci칩n.",
      "Gestiona la comunicaci칩n con la CPU."
    ],
    "correctIndex": 0
  },
  {
    "q": "Sobre el programa:",
    "options": [
      "Se ejecutan leyendo las instrucciones de la memoria principal.",
      "Se ejecuta leyendo las instrucciones del disco.",
      "Se compila desde el disco para ejecutarse.",
      "Est치 escrito en lenguajes de alto nivel siempre."
    ],
    "correctIndex": 0
  },
  {
    "q": "Sobre el reloj del procesador:",
    "options": [
      "Es una se침al cuadrada (ceros y unos).",
      "Es una se침al sinusoidal.",
      "Puede tener cualquier velocidad.",
      "Es una se침al diente de sierra."
    ],
    "correctIndex": 0
  },
  {
    "q": "Sobre la fase Fetch de ejecuci칩n de una instrucci칩n:",
    "options": [
      "Carga datos de memoria.",
      "Carga datos en memoria.",
      "No involucra a la memoria puesto que es la fase en la que traemos la instrucci칩n.",
      "Involucra al banco de registros."
    ],
    "correctIndex": 0
  },
  {
    "q": "Sobre las t칠cnicas para evitar problemas de dependencias en la segmentaci칩n:",
    "options": [
      "Se puede solucionar con instrucciones NOP.",
      "Son solo hardware.",
      "Son solo software.",
      "Si se reordenan las instrucciones se solucionan siempre las dependencia."
    ],
    "correctIndex": 0
  },
  {
    "q": "Solamente opera con registros.",
    "options": [
      "Los bits del c칩digo de operaci칩n de la instrucci칩n le indican directamente qu칠 operaci칩n debe realizar.",
      "Solamente opera con registros.",
      "Trabaja directamente con la memoria.",
      "La entrada zero pone a cero la ALU."
    ],
    "correctIndex": 1
  },
  {
    "q": "Un Gigabyte (GB) equivale a:",
    "options": [
      "1024 Megabytes.",
      "1000 Megabytes.",
      "1024 Kilobytes.",
      "1000 Kilobytes."
    ],
    "correctIndex": 0
  },
  {
    "q": "Un bus de datos de 32 bits puede transmitir:",
    "options": [
      "32 bytes a la vez.",
      "32 bits a la vez.",
      "32 instrucciones a la vez.",
      "32 direcciones a la vez."
    ],
    "correctIndex": 1
  },
  {
    "q": "Un bus paralelo transmite datos:",
    "options": [
      "Bit a bit.",
      "Varios bits simult치neamente (ej. 8, 16, 32 l칤neas).",
      "Inal치mbricamente.",
      "Solo para impresoras."
    ],
    "correctIndex": 1
  },
  {
    "q": "Un bus serie transmite datos:",
    "options": [
      "Bit a bit por un solo canal.",
      "Varios bits simult치neamente por varios canales.",
      "Solo en una direcci칩n.",
      "Sin se침al de reloj."
    ],
    "correctIndex": 0
  },
  {
    "q": "Un ciclo de 1 ns son:",
    "options": [
      "10 G de frecuencia de reloj.",
      "1G de frecuencia de reloj.",
      "No podemos saber la frecuencia de reloj.",
      "2 G de frecuencia de reloj."
    ],
    "correctIndex": 1
  },
  {
    "q": "Un compilador traduce:",
    "options": [
      "C칩digo m치quina a ensamblador.",
      "C칩digo fuente de alto nivel a c칩digo m치quina.",
      "C칩digo m치quina a c칩digo fuente.",
      "Texto a voz."
    ],
    "correctIndex": 1
  },
  {
    "q": "Un compilador...",
    "options": [
      "Convierte todo el c칩digo fuente a c칩digo m치quina antes de su ejecuci칩n.",
      "Convierte todo el c칩digo m치quina a c칩digo ensamblador antes de su ejecuci칩n.",
      "Ejecuta el c칩digo del lenguaje de alto nivel linea a l칤nea.",
      "Es lo mismo que un int칠rprete."
    ],
    "correctIndex": 0
  },
  {
    "q": "Un computador digital:",
    "options": [
      "Los resultados dependen solo de los datos almacenados.",
      "No trabaja con informaci칩n hexadecimal.",
      "Puede leer de la memoria datos de mayor tama침o que el ancho de palabra.",
      "Trabaja internamente con valores de tensi칩n anal칩gicos."
    ],
    "correctIndex": 2
  },
  {
    "q": "Un desbordamiento (overflow) ocurre cuando:",
    "options": [
      "El resultado de una operaci칩n excede el rango de representaci칩n disponible.",
      "Se divide por cero.",
      "Se accede a una direcci칩n de memoria inv치lida.",
      "Se interrumpe el procesador."
    ],
    "correctIndex": 0
  },
  {
    "q": "Un fallo de cach칠 (cache miss) ocurre cuando:",
    "options": [
      "El dato solicitado no se encuentra en la cach칠 y hay que buscarlo en memoria principal.",
      "La cach칠 se rompe.",
      "El dato est치 en la cach칠.",
      "La CPU se detiene."
    ],
    "correctIndex": 0
  },
  {
    "q": "Un perif칠rico de entrada es:",
    "options": [
      "El monitor.",
      "La impresora.",
      "El teclado.",
      "Los altavoces."
    ],
    "correctIndex": 2
  },
  {
    "q": "Un procesador multicore tiene:",
    "options": [
      "Un solo n칰cleo de procesamiento.",
      "M칰ltiples n칰cleos de procesamiento en un solo chip.",
      "M칰ltiples chips en la placa base.",
      "Ninguna de las anteriores."
    ],
    "correctIndex": 1
  },
  {
    "q": "Un puerto USB permite:",
    "options": [
      "Conectar perif칠ricos al computador.",
      "Aumentar la memoria RAM.",
      "Refrigerar el sistema.",
      "Conectar el computador a la corriente el칠ctrica."
    ],
    "correctIndex": 0
  },
  {
    "q": "Un sistema operativo es:",
    "options": [
      "Un programa que gestiona los recursos del hardware y provee servicios a los programas de aplicaci칩n.",
      "Un conjunto de circuitos electr칩nicos.",
      "Un dispositivo de entrada/salida.",
      "Un tipo de memoria."
    ],
    "correctIndex": 0
  },
  {
    "q": "Una GPU est치 especializada en:",
    "options": [
      "Procesamiento de texto.",
      "Procesamiento gr치fico y paralelo masivo.",
      "Gesti칩n de archivos.",
      "Ejecutar el sistema operativo."
    ],
    "correctIndex": 1
  },
  {
    "q": "Una instrucci칩n de salto condicional:",
    "options": [
      "Siempre altera el flujo del programa.",
      "Altera el flujo del programa solo si se cumple una condici칩n (basada en flags).",
      "Detiene el programa.",
      "Llama a una subrutina."
    ],
    "correctIndex": 1
  },
  {
    "q": "Una instrucci칩n es \"lw $t1, 4($t2)\" en MIPS32",
    "code": "lw $t1, 4($t2)",
    "options": [
      "Tipo R",
      "Tipo I",
      "Tipo J",
      "Tipo S"
    ],
    "correctIndex": 1
  },
  {
    "q": "Una interrupci칩n es:",
    "options": [
      "Un fallo en el hardware.",
      "Una se침al enviada a la CPU para detener su ejecuci칩n actual y atender un evento.",
      "Un tipo de instrucci칩n de salto.",
      "El proceso de apagar el computador."
    ],
    "correctIndex": 1
  },
  {
    "q": "Una memoria vol치til se caracteriza por ...",
    "options": [
      "Parte del computador donde se almacenan datos.",
      "Se pierde la informaci칩n si se interrumpe el flujo el칠ctrico.",
      "No necesitar energ칤a para perdurar.",
      "Ninguna de las otras respuestas."
    ],
    "correctIndex": 1
  },
  {
    "q": "쮺u치l es el valor de MIPS de un procesador que funciona a 2 MHz y es capaz de ejecutar una media de 3 instrucciones por ciclo?",
    "options": [
      "6.",
      "3/2.",
      "No podemos saber el valor de MIPS.",
      "2000/3."
    ],
    "correctIndex": 0
  },
  {
    "q": "쮺u치l es la caracter칤stica principal de la arquitectura MIPS32?",
    "options": [
      "No soporta operaciones aritm칠ticas.",
      "Utiliza un conjunto de instrucciones complejo.",
      "Tiene un conjunto reducido de instrucciones.",
      "Es una arquitectura CISC."
    ],
    "correctIndex": 2
  },
  {
    "q": "쮺u치l es la filosof칤a del dise침o RISC?",
    "options": [
      "Complejidad y eficiencia.",
      "Simplicidad y eficiencia.",
      "Simplicidad y lentitud.",
      "Complejidad y lentitud."
    ],
    "correctIndex": 1
  },
  {
    "q": "쮺u치l es la funci칩n del registro de estado (FLAGS) en la CPU?",
    "options": [
      "Indicar condiciones de la 칰ltima operaci칩n de la ALU (acarreo, cero, signo, desbordamiento).",
      "Almacenar el resultado de la operaci칩n.",
      "Controlar el flujo del programa.",
      "Almacenar la direcci칩n de la siguiente instrucci칩n."
    ],
    "correctIndex": 0
  },
  {
    "q": "쮺u치l es la funci칩n principal de la memoria RAM en un computador?",
    "options": [
      "Coordinar las operaciones del sistema.",
      "Almacenar datos de manera permanente.",
      "Almacenar temporalmente las instrucciones y datos que la CPU necesita.",
      "Realizar operaciones aritm칠ticas y l칩gicas."
    ],
    "correctIndex": 2
  },
  {
    "q": "쮺u치l es la funci칩n principal de la ruta de datos en un procesador?",
    "options": [
      "Gestionar y coordinar las operaciones.",
      "Almacenar instrucciones.",
      "Mover y procesar datos.",
      "Realizar operaciones aritm칠ticas y l칩gicas."
    ],
    "correctIndex": 2
  },
  {
    "q": "쮺u치l es una caracter칤stica de la memoria cach칠?",
    "options": [
      "Almacena temporalmente los datos m치s frecuentemente utilizados.",
      "Es utilizada solo para almacenamiento externo.",
      "Es m치s lenta que la memoria principal.",
      "Almacena datos de manera permanente."
    ],
    "correctIndex": 0
  },
  {
    "q": "쮺u치l es una ventaja del lenguaje ensamblador?",
    "options": [
      "Alta portabilidad entre diferentes arquitecturas.",
      "Independencia del hardware espec칤fico.",
      "Facilidad de escritura y legibilidad.",
      "Control y precisi칩n sobre el hardware."
    ],
    "correctIndex": 3
  },
  {
    "q": "쯈u칠 caracter칤stica tiene el formato de instrucciones en MIPS32?",
    "options": [
      "Formato variable de 8 a 32 bits.",
      "Formato variable de 16 a 64 bits.",
      "Formato fijo de 64 bits.",
      "Formato fijo de 32 bits."
    ],
    "correctIndex": 3
  },
  {
    "q": "쯈u칠 componente es conocido como el \"cerebro\" del computador?",
    "options": [
      "La unidad de control.",
      "La memoria RAM.",
      "La unidad central de procesamiento (CPU).",
      "El disco duro."
    ],
    "correctIndex": 2
  },
  {
    "q": "쯈u칠 es el bus de comunicaci칩n en un computador?",
    "options": [
      "Un conjunto de l칤neas de transmisi칩n que permiten la comunicaci칩n entre los componentes del hardware.",
      "Un dispositivo de almacenamiento.",
      "Un tipo de memoria de acceso aleatorio.",
      "Un dispositivo de entrada y salida."
    ],
    "correctIndex": 0
  },
  {
    "q": "쯈u칠 es el juego de instrucciones del MIPS32?",
    "options": [
      "Un conjunto de comandos que el procesador MIPS32 puede ejecutar directamente.",
      "Un conjunto de comandos para procesadores CISC.",
      "Un conjunto de comandos para sistemas operativos.",
      "Un conjunto de comandos que el procesador MIPS32 no puede ejecutar."
    ],
    "correctIndex": 0
  },
  {
    "q": "쯈u칠 es la jerarquia de memoria?",
    "options": [
      "Un tipo de memoria vol치til.",
      "Una estrategia para combinar diferentes tipos de memoria en un sistema.",
      "Un tipo de memoria no vol치til.",
      "Un m칠todo de acceso secuencial."
    ],
    "correctIndex": 1
  },
  {
    "q": "쯈u칠 es la memoria cach칠?",
    "options": [
      "Un bus de comunicaci칩n.",
      "Una memoria m치s r치pida y peque침a que almacena instrucciones y datos frecuentemente utilizados.",
      "Un tipo de memoria de almacenamiento permanente.",
      "Un dispositivo de entrada y salida."
    ],
    "correctIndex": 1
  },
  {
    "q": "쯈u칠 es la memoria no vol치til?",
    "options": [
      "Memoria que se utiliza solo para almacenamiento temporal.",
      "Memoria que pierde los datos cuando se apaga el sistema.",
      "Memoria que se utiliza solo para la cach칠.",
      "Memoria que retiene los datos incluso sin energia."
    ],
    "correctIndex": 3
  },
  {
    "q": "쯈u칠 es la memoria vol치til?",
    "options": [
      "Memoria que pierde los datos cuando se apaga el sistema.",
      "Memoria utilizada solo para la cach칠.",
      "Memoria que retiene los datos incluso sin energ칤a.",
      "Memoria utilizada solo para almacenamiento externo."
    ],
    "correctIndex": 0
  },
  {
    "q": "쯈u칠 es la unidad de control en un procesador?",
    "options": [
      "La parte del procesador que maneja la entrada y salida de datos.",
      "La parte del procesador que gestiona y coordina las operaciones.",
      "La parte del procesador que almacena datos.",
      "La parte del procesador que realiza operaciones aritm칠ticas."
    ],
    "correctIndex": 1
  },
  {
    "q": "쯈u칠 es un fallo de cach칠?",
    "options": [
      "Cuando el bloque solicitado no se encuentra en la cach칠.",
      "Cuando la cach칠 almacena datos permanentemente.",
      "Cuando la cach칠 no necesita ser refrescada.",
      "Cuando el bloque solicitado ya est치 en la cach칠."
    ],
    "correctIndex": 0
  },
  {
    "q": "쯈u칠 es una pseudoinstrucci칩n en MIPS32?",
    "options": [
      "Una instrucci칩n que se corresponde directamente con una instrucci칩n m치quina.",
      "Una instrucci칩n que se utiliza solo en modo kernel.",
      "Una instrucci칩n que el ensamblador traduce a una o m치s instrucciones m치quina.",
      "Una instrucci칩n que no tiene una representaci칩n binaria espec칤fica."
    ],
    "correctIndex": 2
  },
  {
    "q": "쯈u칠 hace este c칩digo?",
    "options": [
      "Multiplica a y b y almacena el resultado en c.",
      "Suma a y b y almacena el resultado en c.",
      "Divide a por b y almacena el resultado en c.",
      "Resta b de a y almacena el resultado en c."
    ],
    "correctIndex": 0,
    "code": "mul $t2, $t0, $t1"
  },
  {
    "q": "쯈u칠 hace este c칩digo?",
    "options": [
      "Divide los valores de a y b y almacena el resultado en c.",
      "Resta el valor de b de a y almacena el resultado en c.",
      "Multiplica los valores de a y b y almacena el resultado en c.",
      "Suma los valores de a y b y almacena el resultado en c."
    ],
    "correctIndex": 1,
    "code": "sub $t2, $t0, $t1"
  },
  {
    "q": "쯈u칠 hace este c칩digo?",
    "options": [
      "Compara x e y, almacena 0 en z si son iguales, de lo contrario almacena 1.",
      "Suma x e y y almacena el resultado en z.",
      "Compara x e y, almacena 1 en z si son iguales, de lo contrario almacena 0.",
      "Resta y de x y almacena el resultado en z."
    ],
    "correctIndex": 2,
    "code": ".data\nx: .word 7\ny: .word 5\nz: .word 0\n.text\nmain:\n  lw $t0, x\n  lw $t1, y\n  beq $t0, $t1, equal\n  bne $t0, $t1, notequal\nequal:\n  li $t2, 1\n  j end\nnotequal:\n  li $t2, 0\nend:\n  sw $t2, z\n  li $v0, 10\n  syscall"
  },
  {
    "q": "쯈u칠 hace este c칩digo?",
    "options": [
      "Suma val y 4 y almacena el resultado en res.",
      "Divide val por 4 y almacena el residuo en res.",
      "Divide val por 4 y almacena el cociente en res.",
      "Resta 4 de val y almacena el resultado en res."
    ],
    "correctIndex": 1,
    "code": "div $t0, $t1\nmfhi $t2"
  },
  {
    "q": "쯈u칠 hace este c칩digo?",
    "options": [
      "Suma los valores de a y b y almacena el resultado en c.",
      "Divide los valores de a y b y almacena el resultado en c.",
      "Resta el valor de b de a y almacena el resultado en c.",
      "Multiplica los valores de a y b y almacena el resultado en c."
    ],
    "correctIndex": 2,
    "code": ".data\na: .word 8\nb: .word 3\nc: .word 0\n.text\nmain:\n  lw $t0, a\n  lw $t1, b\n  sub $t2, $t0, $t1\n  sw $t2, c\n  li $v0, 10\n  syscall"
  },
  {
    "q": "쯈u칠 hace este c칩digo?",
    "options": [
      "Resta y de x y almacena el resultado en z.",
      "Divide x por y y almacena el residuo en z.",
      "Divide x por y y almacena el cociente en z.",
      "Suma x e y y almacena el resultado en z."
    ],
    "correctIndex": 2,
    "code": ".data\nx: .word 10\ny: .word 2\nz: .word 0\n.text\nmain:\n  lw $t0, x\n  lw $t1, y\n  div $t0, $t1\n  mflo $t2\n  sw $t2, z\n  li $v0, 10\n  syscall"
  },
  {
    "q": "쯈u칠 hace este c칩digo?",
    "options": [
      "Resta los valores de i desde 3 hasta 1 y almacena el resultado en sum.",
      "Multiplica los valores de i desde 3 hasta 1 y almacena el resultado en sum.",
      "Suma los valores de i desde 3 hasta 1 y almacena el resultado en sum.",
      "Divide los valores de i desde 3 hasta 1 y almacena el resultado en sum."
    ],
    "correctIndex": 2,
    "code": ".data\ni: .word 3\nsum: .word 0\n.text\nmain:\n  lw $t0, i\n  lw $t1, sum\nloop:\n  add $t1, $t1, $t0\n  addi $t0, $t0, -1\n  bnez $t0, loop\n  sw $t1, sum\n  li $v0, 10\n  syscall"
  },
  {
    "q": "쯈u칠 hace este c칩digo?",
    "options": [
      "Resta 4 de val y almacena el resultado en res.",
      "Suma val y 4 y almacena el resultado en res.",
      "Divide val por 4 y almacena el cociente en res.",
      "Divide val por 4 y almacena el residuo en res."
    ],
    "correctIndex": 3,
    "code": ".data\nval: .word 16\nres: .word 0\n.text\nmain:\n  lw $t0, val\n  li $t1, 4\n  div $t0, $t1\n  mfhi $t2\n  sw $t2, res\n  li $v0, 10\n  syscall"
  },
  {
    "q": "쯈u칠 hace este c칩digo?",
    "code": ".data\ni: .word 4\nsum: .word 0\n.text\nmain:\n  lw $t0, i\n  lw $t1, sum\nloop:\n  add $t1, $t1, $t0\n  addi $t0, $t0, -1\n  bnez $t0, loop\n  sw $t1, sum\n  li $v0, 10\n  syscall",
    "options": [
      "Suma los valores de i desde 4 hasta 1 y almacena el resultado en sum.",
      "Divide los valores de i desde 4 hasta 1 y almacena el resultado en sum.",
      "Multiplica los valores de i desde 4 hasta 1 y almacena el resultado en sum.",
      "Resta los valores de i desde 4 hasta 1 y almacena el resultado en sum."
    ],
    "correctIndex": 0
  },
  {
    "q": "쯈u칠 hace este c칩digo?",
    "code": ".data\nval: .word 12\nres: .word 0\n.text\nmain:\n  lw $t0, val\n  li $t1, 4\n  div $t0, $t1\n  mfhi $t2\n  sw $t2, res\n  li $v0, 10\n  syscall",
    "options": [
      "Divide val por 4 y almacena el residuo en res.",
      "Divide val por 4 y almacena el cociente en res.",
      "Suma val y 4 y almacena el resultado en res.",
      "Resta 4 de val y almacena el resultado en res."
    ],
    "correctIndex": 0
  },
  {
    "q": "쯈u칠 hace este c칩digo?",
    "code": ".data\na: .word 10\nb: .word 20\nc: .word 0\n.text\nmain:\n  lw $t0, a\n  lw $t1, b\n  slt $t2, $t0, $t1\n  sw $t2, c\n  li $v0, 10\n  syscall",
    "options": [
      "Compara si a es menor que b y almacena 1 en c si es verdadero, de lo contrario almacena 0.",
      "Resta el valor de b de a y almacena el resultado en c.",
      "Suma los valores de a y b y almacena el resultado en c.",
      "Divide a entre b y almacena el cociente en c."
    ],
    "correctIndex": 0
  },
  {
    "q": "쯈u칠 hace este c칩digo?",
    "code": ".data\nx: .word 5\ny: .word 10\nz: .word 0\n.text\nmain:\n  lw $t0, x\n  lw $t1, y\n  add $t2, $t0, $t1\n  sw $t2, z\n  li $v0, 10\n  syscall",
    "options": [
      "Suma los valores de x e y y almacena el resultado en z.",
      "Resta y de x y almacena el resultado en z.",
      "Divide x por y y almacena el cociente en z.",
      "Multiplica x por y y almacena el resultado en z."
    ],
    "correctIndex": 0
  },
  {
    "q": "쯈u칠 hace este c칩digo?",
    "code": ".data\nval: .word 9\nres: .word 0\n.text\nmain:\n  lw $t0, val\n  li $t1, 3\n  div $t0, $t1\n  mflo $t2\n  sw $t2, res\n  li $v0, 10\n  syscall",
    "options": [
      "Divide el valor de val por 3 y almacena el resultado en res.",
      "Divide el valor de val por 3 y almacena el residuo en res.",
      "Suma val y 3 y almacena el resultado en res.",
      "Resta 3 de val y almacena el resultado en res."
    ],
    "correctIndex": 0
  },
  {
    "q": "쯈u칠 hace este c칩digo?",
    "code": ".data\ni: .word 1\nsum: .word 0\n.text\nmain:\n  lw $t0, i\n  lw $t1, sum\n  add $t1, $t1, $t0\n  sw $t1, sum\n  li $v0, 10\n  syscall",
    "options": [
      "Suma el valor de i a sum y almacena el resultado en sum.",
      "Resta el valor de i a sum y almacena el resultado en sum.",
      "Multiplica el valor de i por sum y almacena el resultado en sum.",
      "Divide el valor de sum entre i y almacena el resultado en sum."
    ],
    "correctIndex": 0
  },
  {
    "q": "쯈u칠 hace la instrucci칩n 'lb' en MIPS32?",
    "options": [
      "Almacena un byte (8 bits) desde un registro en la memoria.",
      "Carga una palabra (32 bits) desde la memoria en un registro.",
      "Carga un byte (8 bits) desde la memoria en un registro, extendi칠ndolo con signo.",
      "Almacena una palabra (32 bits) desde un registro en la memoria."
    ],
    "correctIndex": 2
  },
  {
    "q": "쯈u칠 hace la instrucci칩n 'lbu' en MIPS32?",
    "options": [
      "Carga un byte (8 bits) desde la memoria en un registro, extendi칠ndolo con ceros (sin signo).",
      "Carga una palabra (32 bits) desde la memoria en un registro.",
      "Almacena un byte (8 bits) desde un registro en la memoria.",
      "Almacena una palabra (32 bits) desde un registro en la memoria."
    ],
    "correctIndex": 0
  },
  {
    "q": "쯈u칠 instrucci칩n en MIPS32 se utiliza para almacenar un byte desde un registro en la memoria?",
    "options": [
      "sw",
      "sb",
      "lb",
      "lw"
    ],
    "correctIndex": 1
  },
  {
    "q": "쯈u칠 instrucci칩n en MIPS32 se utiliza para cargar un byte desde la memoria en un registro, extendi칠ndolo con ceros (sin signo)?",
    "options": [
      "lbu",
      "lw",
      "lb",
      "sb"
    ],
    "correctIndex": 0
  },
  {
    "q": "쯈u칠 instrucci칩n en MIPS32 se utiliza para cargar un valor inmediato en un registro?",
    "options": [
      "sw",
      "sb",
      "li",
      "lw"
    ],
    "correctIndex": 2
  },
  {
    "q": "쯈u칠 instrucci칩n en MIPS32 se utiliza para cargar una palabra desde la memoria en un registro?",
    "options": [
      "lb",
      "sb",
      "sw",
      "lw"
    ],
    "correctIndex": 3
  },
  {
    "q": "쯈u칠 instrucci칩n en MIPS32 se utiliza para sumar dos registros?",
    "options": [
      "SUB",
      "ADD",
      "DIV",
      "MUL"
    ],
    "correctIndex": 1
  },
  {
    "q": "쯈u칠 instrucci칩n en ensamblador se utiliza para mover datos en MIPS32?",
    "options": [
      "SW",
      "MOV",
      "ADD",
      "LW"
    ],
    "correctIndex": 1
  },
  {
    "q": "쯈u칠 instrucci칩n se utiliza para cargar la direcci칩n de una etiqueta o variable en un registro en MIPS32?",
    "options": [
      "li",
      "la",
      "Iw",
      "sw"
    ],
    "correctIndex": 1
  },
  {
    "q": "쯈u칠 modo de direccionamiento utiliza un registro base m치s un valor de desplazamiento?",
    "options": [
      "Direccionamiento inmediato.",
      "Direccionamiento directo a registro.",
      "Direccionamiento impl칤cito.",
      "Direccionamiento indirecto a registro con desplazamiento."
    ],
    "correctIndex": 3
  },
  {
    "q": "쯈u칠 pol칤tica de escritura en cach칠 realiza la escritura tanto en la cach칠 como en la memoria principal?",
    "options": [
      "Escritura directa.",
      "Escritura diferida.",
      "Escritura aleatoria.",
      "Escritura secuencial."
    ],
    "correctIndex": 0
  },
  {
    "q": "쯈u칠 pol칤tica de reemplazo de cach칠 selecciona al azar un bloque para ser reemplazado?",
    "options": [
      "Reemplazo aleatorio.",
      "Reemplazo LRU.",
      "Reemplazo directo.",
      "Reemplazo FIFO."
    ],
    "correctIndex": 0
  },
  {
    "q": "쯈u칠 principio sugiere que si se accede a un dato, es probable que se accedan a otros datos cercanos en la memoria?",
    "options": [
      "Localidad espacial.",
      "Localidad temporal.",
      "Acceso directo.",
      "Acceso aleatorio."
    ],
    "correctIndex": 0
  },
  {
    "q": "쯈u칠 registro en MIPS32 se utiliza como puntero de pila?",
    "options": [
      "$fp",
      "$ra",
      "$gp",
      "$sp"
    ],
    "correctIndex": 3
  },
  {
    "q": "쯈u칠 registro se utiliza para almacenar la direcci칩n de retorno de las subrutinas en MIPS32?",
    "options": [
      "$sp",
      "$ra",
      "$gp",
      "$fp"
    ],
    "correctIndex": 1
  },
  {
    "q": "쯈u칠 se hace en la fase de b칰squeda de instrucci칩n (FETCH)?",
    "options": [
      "Se busca la instrucci칩n en la memoria principal.",
      "Se ejecuta la instrucci칩n.",
      "Se decodifica la instrucci칩n.",
      "Se almacena el resultado de la instrucci칩n."
    ],
    "correctIndex": 0
  },
  {
    "q": "쯈u칠 significa Little Endian en la ordenaci칩n de datos?",
    "options": [
      "No hay una ordenaci칩n espec칤fica.",
      "Los bytes se ordenan de manera aleatoria.",
      "El byte menos significativo se coloca en la primera posici칩n.",
      "El byte m치s significativo se coloca en la primera posici칩n."
    ],
    "correctIndex": 2
  },
  {
    "q": "쯈u칠 tipo de memoria es m치s r치pida pero tambi칠n m치s cara y con menor densidad de almacenamiento?",
    "options": [
      "SRAM.",
      "Memoria flash.",
      "DRAM.",
      "Memoria magn칠tica."
    ],
    "correctIndex": 0
  },
  {
    "q": "쯈u칠 tipo de memoria es vol치til?",
    "options": [
      "Memoria RAM.",
      "Memoria flash.",
      "Memoria ROM.",
      "Discos duros."
    ],
    "correctIndex": 0
  },
  {
    "q": "쯈u칠 tipo de memoria se utiliza para la memoria principal debido a su alta densidad de almacenamiento?",
    "options": [
      "Memoria flash.",
      "DRAM.",
      "Memoria magn칠tica.",
      "SRAM."
    ],
    "correctIndex": 1
  },
  {
    "q": "쯈u칠 tipo de memoria se utiliza principalmente para almacenamiento externo y ofrece alta capacidad a un costo bajo?",
    "options": [
      "Memoria magn칠tica.",
      "Memoria 칩ptica.",
      "Memoria de semiconductores.",
      "Memoria magneto-칩ptica."
    ],
    "correctIndex": 0
  },
  {
    "q": "쯈u칠 tipo de memoria utiliza transistores para almacenar datos en un estado estable?",
    "options": [
      "Memoria flash.",
      "SRAM.",
      "Mernoria magn칠tica.",
      "DRAM."
    ],
    "correctIndex": 1
  },
  {
    "q": "쯈u칠 t칠cnica se usa para permitir que varios dispositivos de E/S transfieran datos directamente a la memoria sin intervenci칩n constante de la CPU?",
    "options": [
      "DMA (Acceso Directo a Memoria).",
      "Interrupciones por hardware.",
      "Encuesta (Polling).",
      "Segmentaci칩n de instrucciones."
    ],
    "correctIndex": 0
  },
  {
    "q": "쯈u칠 hace este c칩digo?",
    "code": ".data\nx: .word 15\ny: .word 5\nz: .word 0\n.text\nmain:\n  lw $t0, x\n  lw $t1, y\n  div $t0, $t1\n  mflo $t2\n  sw $t2, z\n  li $v0, 10\n  syscall",
    "options": [
      "Divide x por y y almacena el cociente en z.",
      "Divide x por y y almacena el residuo en z.",
      "Suma x e y y almacena el resultado en z.",
      "Resta y de x y almacena el resultado en z."
    ],
    "correctIndex": 0
  }
];

    const preguntasSistemasOperativos = [
  {
    "q": "Si el registro de instrucci칩n de un procesador de 32 bits almacena la instrucci칩n 0 de un programa 쯈u칠 valor almacenar치 el contador de programa?",
    "options": [
      "4",
      "3",
      "5",
      "6"
    ],
    "correctIndex": 0
  },
  {
    "q": "Si en el c칩digo tenemos la sentencia a[0]=1",
    "options": [
      "a es igual a &(a[0])",
      "a es igual a &(a[-1])",
      "a es igual a &(a[1])",
      "a es igual a &(a[2])"
    ],
    "correctIndex": 0
  },
  {
    "q": "Si en el c칩digo tenemos la sentencia a[0]=1",
    "options": [
      "*a es igual a 1",
      "*a es igual a 0",
      "*a es igual a 2",
      "*a es igual a 3"
    ],
    "correctIndex": 0
  },
  {
    "q": "Si en el c칩digo tenemos la sentencia char **p",
    "options": [
      "strlen(*p) es una sentencia correcta",
      "Depende de la configuraci?n del sistema.",
      "Se realiza ?nicamente en modo usuario.",
      "Solo ocurre cuando el proceso finaliza."
    ],
    "correctIndex": 0
  },
  {
    "q": "Un intento de divisi칩n entre cero causar치",
    "options": [
      "Una excepci칩n hardware s칤ncrona",
      "Depende de la configuraci?n del sistema.",
      "Se realiza ?nicamente en modo usuario.",
      "Solo ocurre cuando el proceso finaliza."
    ],
    "correctIndex": 0
  },
  {
    "q": "쮻칩nde se almacena la m치scara de interrupciones?",
    "options": [
      "En el registro de estado de la unidad de control",
      "La CPU debe realizar sondeo continuo hasta finalizar la E/S.",
      "No se generan interrupciones al finalizar la transferencia.",
      "El proceso solicitante queda bloqueado siempre en cualquier caso."
    ],
    "correctIndex": 0
  },
  {
    "q": "El falso que la funci칩n printf",
    "options": [
      "Utiliza %d para mostrar cadenas",
      "Depende de la configuraci?n del sistema.",
      "Se realiza ?nicamente en modo usuario.",
      "Solo ocurre cuando el proceso finaliza."
    ],
    "correctIndex": 0
  },
  {
    "q": "Es falso que la funci칩n printf",
    "options": [
      "Utiliza %c para mostrar cadenas de caracteres",
      "Depende de la configuraci?n del sistema.",
      "Se realiza ?nicamente en modo usuario.",
      "Solo ocurre cuando el proceso finaliza."
    ],
    "correctIndex": 0
  },
  {
    "q": "En la sentencia int p[10]: es falso que:",
    "options": [
      "El valor de *p es igual a p[0]",
      "El valor de *p es igual a p[-1]",
      "El valor de *p es igual a p[1]",
      "El valor de *p es igual a p[2]"
    ],
    "correctIndex": 0
  },
  {
    "q": "El falso que la funci칩n printf",
    "options": [
      "Se define en stdlib.h",
      "No se define en stdlib.h",
      "Depende de la configuraci?n del sistema.",
      "Se realiza ?nicamente en modo usuario."
    ],
    "correctIndex": 0
  },
  {
    "q": "쮺u치l de los siguientes no es un registro de la Unidad de Control?",
    "options": [
      "Registro de datos",
      "Depende de la configuraci?n del sistema.",
      "Se realiza ?nicamente en modo usuario.",
      "Solo ocurre cuando el proceso finaliza."
    ],
    "correctIndex": 0
  },
  {
    "q": "쮺u치l es el mecanismo que no permite cambiar el modo de ejecuci칩n de usuario a n칰cleo?",
    "options": [
      "La instrucci칩n RETI",
      "Depende de la configuraci?n del sistema.",
      "Se realiza ?nicamente en modo usuario.",
      "Solo ocurre cuando el proceso finaliza."
    ],
    "correctIndex": 0
  },
  {
    "q": "쯈u칠 estrategias existen para desarrollar las operaciones de E/S?",
    "options": [
      "E/S basada en controladores y E/S basada en manejadores",
      "La CPU debe realizar sondeo continuo hasta finalizar la E/S.",
      "No se generan interrupciones al finalizar la transferencia.",
      "El proceso solicitante queda bloqueado siempre en cualquier caso."
    ],
    "correctIndex": 0
  },
  {
    "q": "Un intento de divisi칩n entre cero causar치:",
    "options": [
      "Una excepci칩n hardware s칤ncrona",
      "Depende de la configuraci?n del sistema.",
      "Se realiza ?nicamente en modo usuario.",
      "Solo ocurre cuando el proceso finaliza."
    ],
    "correctIndex": 0
  },
  {
    "q": "Un archivo de cabecera contiene",
    "options": [
      "Prototipos de funciones",
      "El primer par?metro es la direcci?n del buffer en memoria.",
      "El tercer par?metro indica el n?mero de bytes a leer o escribir.",
      "Un enlace duro crea un nuevo inodo independiente."
    ],
    "correctIndex": 0
  },
  {
    "q": "En un procesador con registros de 32 bits donde la primera palabara en memoria es la palabra 0 쮺u치l ser칤a la direcci칩n de la palabra 1?",
    "options": [
      "4",
      "3",
      "5",
      "6"
    ],
    "correctIndex": 0
  },
  {
    "q": "쮼n qu칠 generaci칩n de los sistemas operativos aparece el concepto de lote de trabajos?",
    "options": [
      "2",
      "1",
      "3",
      "4"
    ],
    "correctIndex": 0
  },
  {
    "q": "쮼l sistema operativo interviene en la operaci칩n de la memoria cach칠?",
    "options": [
      "No, es gestionada exclusivamente por el hardware.",
      "Las direcciones resultantes de la MMU son siempre l?gicas.",
      "No existe fragmentaci?n interna en este esquema.",
      "La traducci?n la realiza el compilador, no el hardware."
    ],
    "correctIndex": 0
  },
  {
    "q": "La instrucci칩n RETI:",
    "options": [
      "Restaura el estado de ejecuci칩n a partir de la pila del sistema.",
      "Depende de la configuraci?n del sistema.",
      "Se realiza ?nicamente en modo usuario.",
      "Solo ocurre cuando el proceso finaliza."
    ],
    "correctIndex": 0
  },
  {
    "q": "Si se declara una variable p como puntero a un valor entero",
    "options": [
      "La variable p no puede contener valores enteros.",
      "Depende de la configuraci?n del sistema.",
      "Se realiza ?nicamente en modo usuario.",
      "Solo ocurre cuando el proceso finaliza."
    ],
    "correctIndex": 0
  },
  {
    "q": "El BCP de un proceso en situaci칩n de Bloqueado y Suspendido:",
    "options": [
      "Deber치 ser actualizado y cambiado de lista cuando tenga lugar el suceso que bloque칩 al proceso",
      "Deber치 ser actualizado y cambiado de lista cuando tenga lugar el suceso que bloque칩 al hebra",
      "Se almacena ?nicamente en los registros generales del procesador.",
      "Permanece siempre en memoria secundaria aunque el proceso est? activo."
    ],
    "correctIndex": 0
  },
  {
    "q": "Se dice que entre los dos procesos existe una relaci칩n padre-hijo si",
    "options": [
      "Uno ha sido creado por el sistema operativo a instancia del otro",
      "Se almacena ?nicamente en los registros generales del procesador.",
      "Permanece siempre en memoria secundaria aunque el proceso est? activo.",
      "Comparte el contador de programa entre todas las hebras."
    ],
    "correctIndex": 0
  },
  {
    "q": "Si un proceso se encuentra en estado de ejecuci칩n",
    "options": [
      "Su estado hardware se almacena en los registros del procesador",
      "Se almacena ?nicamente en los registros generales del procesador.",
      "Permanece siempre en memoria secundaria aunque el proceso est? activo.",
      "Comparte el contador de programa entre todas las hebras."
    ],
    "correctIndex": 0
  },
  {
    "q": "Es falso que el BCP de un proceso pueda encontrarse",
    "options": [
      "En memoria secundaria",
      "En memoria principal",
      "Se almacena ?nicamente en los registros generales del procesador.",
      "Permanece siempre en memoria secundaria aunque el proceso est? activo."
    ],
    "correctIndex": 0
  },
  {
    "q": "Es falso que el BCP de un proceso almacene",
    "options": [
      "Los identificadores de sus procesos hijos",
      "Los identificadores de sus hebras hijos",
      "Se almacena ?nicamente en los registros generales del procesador.",
      "Permanece siempre en memoria secundaria aunque el proceso est? activo."
    ],
    "correctIndex": 0
  },
  {
    "q": "Despu칠s de realizar una orden fork() desde un proceso",
    "options": [
      "El proceso padre y el proceso hijo ejecutan el c칩digo que sigue a la realizaci칩n de la llamada",
      "El hebra padre y el hebra hijo ejecutan el c칩digo que sigue a la realizaci칩n de la llamada",
      "Se almacena ?nicamente en los registros generales del procesador.",
      "Permanece siempre en memoria secundaria aunque el proceso est? activo."
    ],
    "correctIndex": 0
  },
  {
    "q": "El cuarto par치metro de la funci칩n pthread_create indica",
    "options": [
      "Los atributos con que se llamar치 a la funci칩n sobre la que se crea una hebra",
      "Los atributos con que se llamar치 a la funci칩n sobre la que se crea una proceso",
      "Se almacena ?nicamente en los registros generales del procesador.",
      "Permanece siempre en memoria secundaria aunque el proceso est? activo."
    ],
    "correctIndex": 0
  },
  {
    "q": "La imagen de memoria de un proceso en un sistema con memoria virtual",
    "options": [
      "Puede tener elementos almacenados en espacio de almacenamiento secundario",
      "No puede tener elementos almacenados en espacio de almacenamiento secundario",
      "Se almacena ?nicamente en los registros generales del procesador.",
      "Permanece siempre en memoria secundaria aunque el proceso est? activo."
    ],
    "correctIndex": 0
  },
  {
    "q": "쮺u치l de la siguiente informaci칩n NO es almacenado por el BCP de un proceso?",
    "options": [
      "칔ltima instrucci칩n ejecutada",
      "Se almacena ?nicamente en los registros generales del procesador.",
      "Permanece siempre en memoria secundaria aunque el proceso est? activo.",
      "Comparte el contador de programa entre todas las hebras."
    ],
    "correctIndex": 0
  },
  {
    "q": "La funci칩n pthread_join sirve para",
    "options": [
      "Esperar a una hebra",
      "Esperar a una proceso",
      "Se almacena ?nicamente en los registros generales del procesador.",
      "Permanece siempre en memoria secundaria aunque el proceso est? activo."
    ],
    "correctIndex": 0
  },
  {
    "q": "El primer par치metro de la funci칩n pthread_create indica",
    "options": [
      "La estructura que almacenar치 los datos de la hebra",
      "La estructura que almacenar치 los datos de la proceso",
      "Se almacena ?nicamente en los registros generales del procesador.",
      "Permanece siempre en memoria secundaria aunque el proceso est? activo."
    ],
    "correctIndex": 0
  },
  {
    "q": "Un proceso en estado bloquea",
    "options": [
      "Ha pasado al menos una vez por el estado de ejecuci칩n",
      "Se almacena ?nicamente en los registros generales del procesador.",
      "Permanece siempre en memoria secundaria aunque el proceso est? activo.",
      "Comparte el contador de programa entre todas las hebras."
    ],
    "correctIndex": 0
  },
  {
    "q": "Las hebras definidas sobre un proceso",
    "options": [
      "Tienen cada una su propio estado del procesador.",
      "No tienen cada una su propio estado del procesador.",
      "Se almacena ?nicamente en los registros generales del procesador.",
      "Permanece siempre en memoria secundaria aunque el proceso est? activo."
    ],
    "correctIndex": 0
  },
  {
    "q": "El segundo par치metro de la funci칩n pthread_create indica",
    "options": [
      "Los atributos con que se llamar치 a la funci칩n sobre la que se crea una hebra",
      "Los atributos con que se llamar치 a la funci칩n sobre la que se crea una proceso",
      "Se almacena ?nicamente en los registros generales del procesador.",
      "Permanece siempre en memoria secundaria aunque el proceso est? activo."
    ],
    "correctIndex": 0
  },
  {
    "q": "쮺u치l de las siguientes afirmaciones es falsa para las hebras definidas en un proceso?",
    "options": [
      "Comparten el espacio de pila del proceso.",
      "Comparten el espacio de pila del hebra.",
      "Se almacena ?nicamente en los registros generales del procesador.",
      "Permanece siempre en memoria secundaria aunque el proceso est? activo."
    ],
    "correctIndex": 0
  },
  {
    "q": "Si un proceso se encuentra en estado listo",
    "options": [
      "Su estado hardware se almacena en su BCP.",
      "Su estado hardware se almacena en su tabla de p?ginas.",
      "Se almacena ?nicamente en los registros generales del procesador.",
      "Permanece siempre en memoria secundaria aunque el proceso est? activo."
    ],
    "correctIndex": 0
  },
  {
    "q": "El BCP contendr치",
    "options": [
      "Elementos de tama침o fijo",
      "Se almacena ?nicamente en los registros generales del procesador.",
      "Permanece siempre en memoria secundaria aunque el proceso est? activo.",
      "Comparte el contador de programa entre todas las hebras."
    ],
    "correctIndex": 0
  },
  {
    "q": "Un proceso es",
    "options": [
      "Una entidad l칩gica creada por el Sistema Operativo.",
      "Se almacena ?nicamente en los registros generales del procesador.",
      "Permanece siempre en memoria secundaria aunque el proceso est? activo.",
      "Comparte el contador de programa entre todas las hebras."
    ],
    "correctIndex": 0
  },
  {
    "q": "Si una hebra accede al valor de una variable del segmento de datos del proceso",
    "options": [
      "Deber치 sincronizar su ejecuci칩n con otras hebras.",
      "Deber치 sincronizar su ejecuci칩n con otras procesos.",
      "Se almacena ?nicamente en los registros generales del procesador.",
      "Permanece siempre en memoria secundaria aunque el proceso est? activo."
    ],
    "correctIndex": 0
  },
  {
    "q": "Que un proceso est칠 suspendido significa:",
    "options": [
      "Que su imagen de memoria al completo se encuentra en memoria secundaria.",
      "Que su imagen de memoria al completo se encuentra en memoria principal.",
      "Se almacena ?nicamente en los registros generales del procesador.",
      "Permanece siempre en memoria secundaria aunque el proceso est? activo."
    ],
    "correctIndex": 0
  },
  {
    "q": "El tiempo de retorno es un par치metro de rendimiento que significa",
    "options": [
      "El tiempo requerido para su ejecuci칩n m치s el tiempo que permanece a la espera de los recursos solicitados",
      "Depende de la configuraci?n del sistema.",
      "Se realiza ?nicamente en modo usuario.",
      "Solo ocurre cuando el proceso finaliza."
    ],
    "correctIndex": 0
  },
  {
    "q": "El planificador a corto plazo",
    "options": [
      "Se ejecuta para decidir qu칠 proceso en estado de listo toma el control del procesador",
      "Se ejecuta para decidir qu칠 proceso en estado de bloqueado toma el control del procesador",
      "Se ejecuta para decidir qu칠 hebra en estado de listo toma el control del procesador",
      "No se ejecuta para decidir qu칠 proceso en estado de listo toma el control del procesador"
    ],
    "correctIndex": 0
  },
  {
    "q": "Suponga una pol칤tica de planificaci칩n basada en FCFS",
    "options": [
      "Si un proceso ocupa el procesador puede ejecutar hasta terminar",
      "Si un hebra ocupa el procesador puede ejecutar hasta terminar",
      "Lo decide el planificador a largo plazo, no el de corto plazo.",
      "Asigna el mayor quantum al proceso con mayor prioridad en cada turno."
    ],
    "correctIndex": 0
  },
  {
    "q": "Suponga una pol칤tica de planificaci칩n basada en FCFS",
    "options": [
      "Si un proceso es desbloqueado puede tener que esperar a que acaben todos los insertados en la cola de listos.",
      "Si un proceso es desbloqueado puede tener que esperar a que acaben todos los insertados en la cola de bloqueados.",
      "Si un proceso es deslisto puede tener que esperar a que acaben todos los insertados en la cola de listos.",
      "Si un proceso es desejecuci?n puede tener que esperar a que acaben todos los insertados en la cola de listos."
    ],
    "correctIndex": 0
  },
  {
    "q": "Suponga una pol칤tica de planificaci칩n Round-Robin con quantum q=6",
    "options": [
      "El sistema operativo se ejecutar치 como m칤nimo cada 6 u.t",
      "El sistema operativo se ejecutar치 como m칤nimo cada 5 u.t",
      "El sistema operativo se ejecutar치 como m칤nimo cada 7 u.t",
      "El sistema operativo se ejecutar치 como m칤nimo cada 8 u.t"
    ],
    "correctIndex": 0
  },
  {
    "q": "Suponga una pol칤tica de planificaci칩n Round-Robin con quantum q=6 y n procesos en la cola de procesos listos",
    "options": [
      "Un nuevo proceso esperar치 como m치ximo n * 6 u.t",
      "Un nuevo proceso esperar치 como m치ximo n * 5 u.t",
      "Un nuevo proceso esperar치 como m치ximo n * 7 u.t",
      "Un nuevo proceso esperar치 como m치ximo n * 8 u.t"
    ],
    "correctIndex": 0
  },
  {
    "q": "Suponga una pol칤tica de planificaci칩n Round-Robin con quantum q=6 y n procesos en la cola de procesos listos:",
    "options": [
      "Un proceso nuevo se inserta al final de la cola en cualquier caso.",
      "Un hebra nuevo se inserta al final de la cola en cualquier caso.",
      "Lo decide el planificador a largo plazo, no el de corto plazo.",
      "Asigna el mayor quantum al proceso con mayor prioridad en cada turno."
    ],
    "correctIndex": 0
  },
  {
    "q": "Suponga una pol칤tica de planificaci칩n Round-Robin con quantum q=4",
    "options": [
      "Si un proceso termina antes del quantum, otro proceso puede ocupar el procesador durante 4 u.t",
      "Si un proceso termina antes del quantum, otro proceso puede ocupar el procesador durante 3 u.t",
      "Si un proceso termina antes del quantum, otro proceso puede ocupar el procesador durante 5 u.t",
      "Si un proceso termina antes del quantum, otro proceso puede ocupar el procesador durante 6 u.t"
    ],
    "correctIndex": 0
  },
  {
    "q": "Suponga una pol칤tica de planificaci칩n Round-Robin con quantum q=4 y n procesos bloqueados",
    "options": [
      "Un proceso bloqueado que pase a listo se insertar치 en la cola despu칠s que un nuevo proceso",
      "Un proceso bloqueado que pase a bloqueado se insertar치 en la cola despu칠s que un nuevo proceso",
      "Un proceso listo que pase a listo se insertar치 en la cola despu칠s que un nuevo proceso",
      "Un proceso ejecuci?n que pase a listo se insertar치 en la cola despu칠s que un nuevo proceso"
    ],
    "correctIndex": 0
  },
  {
    "q": "Suponga una pol칤tica de planificaci칩n de colas multinivel y prioridad est치tica",
    "options": [
      "Los procesos pueden ejecutar durante un quantum distinto en funci칩n de la cola.",
      "Los hebras pueden ejecutar durante un quantum distinto en funci칩n de la cola.",
      "Los procesos pueden ejecutar durante un prioridad distinto en funci칩n de la cola.",
      "Lo decide el planificador a largo plazo, no el de corto plazo."
    ],
    "correctIndex": 0
  },
  {
    "q": "El algoritmo de planificaci칩n Round-Robin consiste en",
    "options": [
      "Asignar circularmente el mismo tiempo de CPU a todos los procesos del sistema",
      "Asignar circularmente el mismo tiempo de entrada/salida a todos los procesos del sistema",
      "Asignar circularmente el mismo tiempo de CPU a todos los hebras del sistema",
      "Lo decide el planificador a largo plazo, no el de corto plazo."
    ],
    "correctIndex": 0
  },
  {
    "q": "El primer par치metro de la funci칩n sched_setaffinity determina",
    "options": [
      "El pid del proceso",
      "El pid del hebra",
      "Depende de la configuraci?n del sistema.",
      "Se realiza ?nicamente en modo usuario."
    ],
    "correctIndex": 0
  },
  {
    "q": "El par치metro de planificaci칩n denominado Tiempo de Retorno indica",
    "options": [
      "El tiempo total de permanencia de un proceso en el sistema",
      "El tiempo total de permanencia de un hebra en el sistema",
      "Depende de la configuraci?n del sistema.",
      "Se realiza ?nicamente en modo usuario."
    ],
    "correctIndex": 0
  },
  {
    "q": "La funci칩n sched_setaffinity",
    "options": [
      "No tiene efecto si hay un solo procesador",
      "Depende de la configuraci?n del sistema.",
      "Se realiza ?nicamente en modo usuario.",
      "Solo ocurre cuando el proceso finaliza."
    ],
    "correctIndex": 0
  },
  {
    "q": "La funci칩n del planificador a largo plazo consiste en",
    "options": [
      "Dar entrada al sistema a nuevos procesos.",
      "Dar entrada al sistema a nuevos hebras.",
      "Lo decide el planificador a largo plazo, no el de corto plazo.",
      "Asigna el mayor quantum al proceso con mayor prioridad en cada turno."
    ],
    "correctIndex": 0
  },
  {
    "q": "En una pol칤tica de planificaci칩n expropiativa",
    "options": [
      "El sistema operativo puede tomar el control del procesador en cualquier momento.",
      "Depende de la configuraci?n del sistema.",
      "Se realiza ?nicamente en modo usuario.",
      "Solo ocurre cuando el proceso finaliza."
    ],
    "correctIndex": 0
  },
  {
    "q": "Considerando prioridades est치ticas y din치micas, el n칰mero total de niveles de prioridad en un sistema POSIX ser치",
    "options": [
      "139",
      "138",
      "140",
      "141"
    ],
    "correctIndex": 0
  },
  {
    "q": "El sistema de prioridad nice",
    "options": [
      "Es un sistema de prioridades din치micas.",
      "Es un sistema de quantumes din치micas.",
      "No es un sistema de prioridades din치micas.",
      "Lo decide el planificador a largo plazo, no el de corto plazo."
    ],
    "correctIndex": 0
  },
  {
    "q": "La funci칩n sched_getaffinity:",
    "options": [
      "Puede asignar una m치scaras de procesadores a un puntero.",
      "No puede asignar una m치scaras de procesadores a un puntero.",
      "Depende de la configuraci?n del sistema.",
      "Se realiza ?nicamente en modo usuario."
    ],
    "correctIndex": 0
  },
  {
    "q": "El entrelazado de ejecuci칩n de un conjunto de procesos",
    "options": [
      "Lo establece el programador de las aplicaciones",
      "Se almacena ?nicamente en los registros generales del procesador.",
      "Permanece siempre en memoria secundaria aunque el proceso est? activo.",
      "Comparte el contador de programa entre todas las hebras."
    ],
    "correctIndex": 0
  },
  {
    "q": "En una variable de condici칩n",
    "options": [
      "El bloqueo de un proceso conlleva el desbloqueo de un cerrojo",
      "El bloqueo de un hebra conlleva el desbloqueo de un cerrojo",
      "Depende de la configuraci?n del sistema.",
      "Se realiza ?nicamente en modo usuario."
    ],
    "correctIndex": 0
  },
  {
    "q": "Si un sem치foro general tiene valor 0",
    "options": [
      "Ning칰n proceso que invoque a wait podr치 entrar en regi칩n cr칤tica",
      "Ning칰n hebra que invoque a wait podr치 entrar en regi칩n cr칤tica",
      "Depende de la configuraci?n del sistema.",
      "Se realiza ?nicamente en modo usuario."
    ],
    "correctIndex": 0
  },
  {
    "q": "Si un sem치foro general tiene valor 2",
    "options": [
      "Una llamada a wait lo dejar치 a 1",
      "Una llamada a wait lo dejar치 a 0",
      "Una llamada a wait lo dejar치 a 2",
      "Una llamada a wait lo dejar치 a 3"
    ],
    "correctIndex": 0
  },
  {
    "q": "Sea una regi칩n cr칤tica donde puede haber hasta tres procesos en ejecuci칩n",
    "options": [
      "Si la regi칩n es controlada por un sem치foro general este puede tomar el valor 2",
      "Si la regi칩n es controlada por un sem치foro general este puede tomar el valor 1",
      "Si la regi칩n es controlada por un sem치foro general este puede tomar el valor 3",
      "Si la regi칩n es controlada por un sem치foro general este puede tomar el valor 4"
    ],
    "correctIndex": 0
  },
  {
    "q": "Sea una regi칩n cr칤tica donde puede haber hasta tres procesos en ejecuci칩n",
    "options": [
      "Si la regi칩n es controlada por un sem치foro general este puede tomar valor -4",
      "Si la regi칩n es controlada por un sem치foro general este puede tomar valor -3",
      "Si la regi칩n es controlada por un sem치foro general este puede tomar valor -5",
      "Si la regi칩n es controlada por un sem치foro general este puede tomar valor -6"
    ],
    "correctIndex": 0
  },
  {
    "q": "La llamada send",
    "options": [
      "Si es s칤ncrona es bloqueante",
      "Depende de la configuraci?n del sistema.",
      "Se realiza ?nicamente en modo usuario.",
      "Solo ocurre cuando el proceso finaliza."
    ],
    "correctIndex": 0
  },
  {
    "q": "Si un sem치foro general tiene valor 1",
    "options": [
      "Una llamada a wait lo dejar치 a 0",
      "Una llamada a wait lo dejar치 a -1",
      "Una llamada a wait lo dejar치 a 1",
      "Una llamada a wait lo dejar치 a 2"
    ],
    "correctIndex": 0
  },
  {
    "q": "El quinto par치metro de la primitiva mmap corresponde a",
    "options": [
      "El archivo que se proyectar치",
      "Depende de la configuraci?n del sistema.",
      "Se realiza ?nicamente en modo usuario.",
      "Solo ocurre cuando el proceso finaliza."
    ],
    "correctIndex": 0
  },
  {
    "q": "El segundo par치metro de la llamada a pthread_cond_wait corresponde a un mutex que",
    "options": [
      "Se liberar치 en la llamada",
      "No se liberar치 en la llamada",
      "Se almacena ?nicamente en los registros generales del procesador.",
      "Permanece siempre en memoria secundaria aunque el proceso est? activo."
    ],
    "correctIndex": 0
  },
  {
    "q": "Si un sem치foro general tiene valor 1:",
    "options": [
      "Una llamada a wait lo dejar치 a cero.",
      "Depende de la configuraci?n del sistema.",
      "Se realiza ?nicamente en modo usuario.",
      "Solo ocurre cuando el proceso finaliza."
    ],
    "correctIndex": 0
  },
  {
    "q": "Si un sem치foro general tiene valor 2:",
    "options": [
      "Una llamada a wait lo dejar치 a 1",
      "Una llamada a wait lo dejar치 a 0",
      "Una llamada a wait lo dejar치 a 2",
      "Una llamada a wait lo dejar치 a 3"
    ],
    "correctIndex": 0
  },
  {
    "q": "Si un sem치foro general tiene valor 2",
    "options": [
      "Puede haber procesos en la regi칩n cr칤tica que controle",
      "Puede haber hebras en la regi칩n cr칤tica que controle",
      "No puede haber procesos en la regi칩n cr칤tica que controle",
      "Depende de la configuraci?n del sistema."
    ],
    "correctIndex": 0
  },
  {
    "q": "En un sem치foro general",
    "options": [
      "La llamada signal siempre incrementar치 el contador del sem치foro.",
      "Depende de la configuraci?n del sistema.",
      "Se realiza ?nicamente en modo usuario.",
      "Solo ocurre cuando el proceso finaliza."
    ],
    "correctIndex": 0
  },
  {
    "q": "Si un proceso recibe una se침al:",
    "options": [
      "Se alterar치 su flujo de ejecuci칩n si la se침al no se ignora",
      "No se alterar치 su flujo de ejecuci칩n si la se침al no se ignora",
      "Se almacena ?nicamente en los registros generales del procesador.",
      "Permanece siempre en memoria secundaria aunque el proceso est? activo."
    ],
    "correctIndex": 0
  },
  {
    "q": "Un recurso cr칤tico, necesariamente",
    "options": [
      "Tiene que ser accedido dentro de una regi칩n cr칤tica.",
      "No tiene que ser accedido dentro de una regi칩n cr칤tica.",
      "Depende de la configuraci?n del sistema.",
      "Se realiza ?nicamente en modo usuario."
    ],
    "correctIndex": 0
  },
  {
    "q": "El primer par치metro de la primitiva mmap corresponde a:",
    "options": [
      "La zona de memoria compartida",
      "Depende de la configuraci?n del sistema.",
      "Se realiza ?nicamente en modo usuario.",
      "Solo ocurre cuando el proceso finaliza."
    ],
    "correctIndex": 0
  },
  {
    "q": "En la llamada a read sobre un pipe:",
    "options": [
      "El segundo par치metro indica la posici칩n de memoria sobre la que se escribir치 lo leido del pipe.",
      "El primer par?metro es la direcci?n del buffer en memoria.",
      "El tercer par?metro indica el n?mero de bytes a leer o escribir.",
      "Un enlace duro crea un nuevo inodo independiente."
    ],
    "correctIndex": 0
  },
  {
    "q": "En un pipe:",
    "options": [
      "No se puede establecer comunicaci칩n entre procesos ubicados en m치quinas distintas.",
      "No se puede establecer comunicaci칩n entre hebras ubicados en m치quinas distintas.",
      "Depende de la configuraci?n del sistema.",
      "Se realiza ?nicamente en modo usuario."
    ],
    "correctIndex": 0
  },
  {
    "q": "Si utilizamos un cerrojo para proteger una secci칩n cr칤tica:",
    "options": [
      "No podr치 haber m치s que un proceso en la secci칩n cr칤tica.",
      "No podr치 haber m치s que un hebra en la secci칩n cr칤tica.",
      "Depende de la configuraci?n del sistema.",
      "Se realiza ?nicamente en modo usuario."
    ],
    "correctIndex": 0
  },
  {
    "q": "Sea una regi칩n cr칤tica donde puede haber hasta dos procesos en ejecuci칩n:",
    "options": [
      "La regi칩n no puede ser controlada por un sem치foro binario.",
      "Se almacena ?nicamente en los registros generales del procesador.",
      "Permanece siempre en memoria secundaria aunque el proceso est? activo.",
      "Comparte el contador de programa entre todas las hebras."
    ],
    "correctIndex": 0
  },
  {
    "q": "En la llamada a write sobre un pipe:",
    "options": [
      "El segundo par치metro indica la posici칩n de memoria que se escribir치 en el pipe.",
      "El primer par?metro es la direcci?n del buffer en memoria.",
      "El tercer par?metro indica el n?mero de bytes a leer o escribir.",
      "Un enlace duro crea un nuevo inodo independiente."
    ],
    "correctIndex": 0
  },
  {
    "q": "Una zona de memoria compartida",
    "options": [
      "Tendr치 las mismas direcciones f칤sicas en los espacios de memoria de los procesos que lo comparten",
      "Tendr치 las mismas direcciones f칤sicas en los espacios de memoria de los hebras que lo comparten",
      "Las direcciones resultantes de la MMU son siempre l?gicas.",
      "No existe fragmentaci?n interna en este esquema."
    ],
    "correctIndex": 0
  },
  {
    "q": "En un esquema de memoria virtual basado en segmentaci칩n",
    "options": [
      "Cada segmento puede tener distintos permisos de acceso",
      "Las direcciones resultantes de la MMU son siempre l?gicas.",
      "No existe fragmentaci?n interna en este esquema.",
      "La traducci?n la realiza el compilador, no el hardware."
    ],
    "correctIndex": 0
  },
  {
    "q": "En un esquema de memoria virtual basado en segmentaci칩n",
    "options": [
      "Cada segmento tendr치 sus propios permisos de acceso",
      "Las direcciones resultantes de la MMU son siempre l?gicas.",
      "No existe fragmentaci?n interna en este esquema.",
      "La traducci?n la realiza el compilador, no el hardware."
    ],
    "correctIndex": 0
  },
  {
    "q": "En un esquema de memoria virtual basado en segmentaci칩n",
    "options": [
      "El desplazamiento tiene que ser comparado con la longitud de 칠ste",
      "Las direcciones resultantes de la MMU son siempre l?gicas.",
      "No existe fragmentaci?n interna en este esquema.",
      "La traducci?n la realiza el compilador, no el hardware."
    ],
    "correctIndex": 0
  },
  {
    "q": "En un esquema de memoria virtual basado en segmentaci칩n.",
    "options": [
      "Los segmentos pueden diferir en tama침o.",
      "Las direcciones resultantes de la MMU son siempre l?gicas.",
      "No existe fragmentaci?n interna en este esquema.",
      "La traducci?n la realiza el compilador, no el hardware."
    ],
    "correctIndex": 0
  },
  {
    "q": "Es un esquema de memoria virtual basado en segmentaci칩n",
    "options": [
      "Los segmentos pueden diferir en tama침o",
      "Las direcciones resultantes de la MMU son siempre l?gicas.",
      "No existe fragmentaci?n interna en este esquema.",
      "La traducci?n la realiza el compilador, no el hardware."
    ],
    "correctIndex": 0
  },
  {
    "q": "Las direcciones l칩gicas de un proceso",
    "options": [
      "Son la entrada a la MMU",
      "No son la entrada a la MMU",
      "Se almacena ?nicamente en los registros generales del procesador.",
      "Permanece siempre en memoria secundaria aunque el proceso est? activo."
    ],
    "correctIndex": 0
  },
  {
    "q": "Las direcciones l칩gicas de un proceso",
    "options": [
      "Comienzan siempre en la posici칩n 0",
      "Comienzan siempre en la posici칩n -1",
      "Comienzan siempre en la posici칩n 1",
      "Comienzan siempre en la posici칩n 2"
    ],
    "correctIndex": 0
  },
  {
    "q": "Con particiones din치micas",
    "options": [
      "No hay fragmentaci칩n interna",
      "Depende de la configuraci?n del sistema.",
      "Se realiza ?nicamente en modo usuario.",
      "Solo ocurre cuando el proceso finaliza."
    ],
    "correctIndex": 0
  },
  {
    "q": "En memoria virtual que utilice un esquema de paginaci칩n",
    "options": [
      "Las direcciones resultantes de la MMU son direcciones f칤sicas",
      "Las direcciones resultantes de la MMU son siempre l?gicas.",
      "No existe fragmentaci?n interna en este esquema.",
      "La traducci?n la realiza el compilador, no el hardware."
    ],
    "correctIndex": 0
  },
  {
    "q": "En memoria virtual que utilice un esquema de paginaci칩n",
    "options": [
      "El n칰mero de posiciones de una p치gina es elevado a 2 a n",
      "El n칰mero de posiciones de una p치gina es elevado a 1 a n",
      "El n칰mero de posiciones de una p치gina es elevado a 3 a n",
      "El n칰mero de posiciones de una p치gina es elevado a 4 a n"
    ],
    "correctIndex": 0
  },
  {
    "q": "En memoria virtual que utilice un esquema de paginaci칩n",
    "options": [
      "No existe fragmentaci칩n externa",
      "Las direcciones resultantes de la MMU son siempre l?gicas.",
      "No existe fragmentaci?n interna en este esquema.",
      "La traducci?n la realiza el compilador, no el hardware."
    ],
    "correctIndex": 0
  },
  {
    "q": "En memoria virtual que utilice un esquema de paginaci칩n",
    "options": [
      "Las direcciones l칩gicas coinciden con las direcciones secuenciales del proceso",
      "Las direcciones l칩gicas coinciden con las direcciones secuenciales del hebra",
      "Las direcciones resultantes de la MMU son siempre l?gicas.",
      "No existe fragmentaci?n interna en este esquema."
    ],
    "correctIndex": 0
  },
  {
    "q": "En memoria virtual que utilice un esquema de paginaci칩n",
    "options": [
      "Existe fragmentaci칩n interna",
      "Las direcciones resultantes de la MMU son siempre l?gicas.",
      "No existe fragmentaci?n interna en este esquema.",
      "La traducci?n la realiza el compilador, no el hardware."
    ],
    "correctIndex": 0
  },
  {
    "q": "Una zona de memoria compartida",
    "options": [
      "Pueden contener direcciones f칤sicas referenciadas por direcciones l칩gicas distintas en los espacios de memoria de los procesos que la comparten",
      "Pueden contener direcciones f칤sicas referenciadas por direcciones l칩gicas distintas en los espacios de memoria de los hebras que la comparten",
      "No pueden contener direcciones f칤sicas referenciadas por direcciones l칩gicas distintas en los espacios de memoria de los procesos que la comparten",
      "Las direcciones resultantes de la MMU son siempre l?gicas."
    ],
    "correctIndex": 0
  },
  {
    "q": "Las funciones de bibliotecas din치micas",
    "options": [
      "Se invocan a trav칠s de una llamada al sistema operativo",
      "No se invocan a trav칠s de una llamada al sistema operativo",
      "Depende de la configuraci?n del sistema.",
      "Se realiza ?nicamente en modo usuario."
    ],
    "correctIndex": 0
  },
  {
    "q": "Con particiones fijas de distinto tama침o",
    "options": [
      "Hay fragmentaci칩n externa",
      "Depende de la configuraci?n del sistema.",
      "Se realiza ?nicamente en modo usuario.",
      "Solo ocurre cuando el proceso finaliza."
    ],
    "correctIndex": 0
  },
  {
    "q": "Con particiones fijas del mismo tama침o:",
    "options": [
      "La eficiencia del almacenamiento no depende de la partici칩n en la que se ubique cada proceso.",
      "La eficiencia del almacenamiento no depende de la partici칩n en la que se ubique cada hebra.",
      "Depende de la configuraci?n del sistema.",
      "Se realiza ?nicamente en modo usuario."
    ],
    "correctIndex": 0
  },
  {
    "q": "Las direcciones l칩gicas de un proceso:",
    "options": [
      "Son la entrada a la MMU",
      "No son la entrada a la MMU",
      "Se almacena ?nicamente en los registros generales del procesador.",
      "Permanece siempre en memoria secundaria aunque el proceso est? activo."
    ],
    "correctIndex": 0
  },
  {
    "q": "Las direcciones l칩gicas de un proceso:",
    "options": [
      "Comienzan siempre en la posici칩n 0.",
      "Comienzan siempre en la posici칩n -1.",
      "Comienzan siempre en la posici칩n 1.",
      "Comienzan siempre en la posici칩n 2."
    ],
    "correctIndex": 0
  },
  {
    "q": "Las funciones de bibliotecas est치ticas",
    "options": [
      "Se integran en los archivos ejecutables",
      "No se integran en los archivos ejecutables",
      "Depende de la configuraci?n del sistema.",
      "Se realiza ?nicamente en modo usuario."
    ],
    "correctIndex": 0
  },
  {
    "q": "La imagen de memoria de un proceso:",
    "options": [
      "Se construye directamente sobre memoria virtual.",
      "Se construye directamente sobre memoria f?sica.",
      "No se construye directamente sobre memoria virtual.",
      "Se almacena ?nicamente en los registros generales del procesador."
    ],
    "correctIndex": 0
  },
  {
    "q": "Si se utiliza una entrada/salida por interrupciones",
    "options": [
      "El proceso que solicita una operaci칩n de entrada/salida puede seguir ejecutando y se le enviar치 una interrupci칩n cuando la solicitud haya concluido.",
      "El proceso que solicita una operaci칩n de CPU puede seguir ejecutando y se le enviar치 una interrupci칩n cuando la solicitud haya concluido.",
      "El hebra que solicita una operaci칩n de entrada/salida puede seguir ejecutando y se le enviar치 una interrupci칩n cuando la solicitud haya concluido.",
      "La CPU debe realizar sondeo continuo hasta finalizar la E/S."
    ],
    "correctIndex": 0
  },
  {
    "q": "Si se utiliza una entrada/salida por interrupciones",
    "options": [
      "S칩lo se puede atender a una interrupci칩n cuando se ejecute un proceso de usuario",
      "S칩lo se puede atender a una interrupci칩n cuando se ejecute un hebra de usuario",
      "La CPU debe realizar sondeo continuo hasta finalizar la E/S.",
      "No se generan interrupciones al finalizar la transferencia."
    ],
    "correctIndex": 0
  },
  {
    "q": "Si se utiliza una entrada/salida por interrupciones:",
    "options": [
      "La atenci칩n de una interrupci칩n siempre se realiza en modo n칰cleo.",
      "La CPU debe realizar sondeo continuo hasta finalizar la E/S.",
      "No se generan interrupciones al finalizar la transferencia.",
      "El proceso solicitante queda bloqueado siempre en cualquier caso."
    ],
    "correctIndex": 0
  },
  {
    "q": "Si se utiliza una entrada/salida por interrupciones:",
    "options": [
      "El proceso interrumpido no puede ser el mismo que solicit칩 la operaci칩n",
      "El hebra interrumpido no puede ser el mismo que solicit칩 la operaci칩n",
      "La CPU debe realizar sondeo continuo hasta finalizar la E/S.",
      "No se generan interrupciones al finalizar la transferencia."
    ],
    "correctIndex": 0
  },
  {
    "q": "Si se utiliza una entrada/salida por DMA",
    "options": [
      "Se emite una interrupci칩n cuando los datos est치n en memoria",
      "No se emite una interrupci칩n cuando los datos est치n en memoria",
      "La CPU debe realizar sondeo continuo hasta finalizar la E/S.",
      "No se generan interrupciones al finalizar la transferencia."
    ],
    "correctIndex": 0
  },
  {
    "q": "Si se utiliza una entrada/salida por DMA:",
    "options": [
      "El proceso que solicita una operaci칩n queda bloqueado hasta que 칠sta se complete.",
      "El proceso que solicita una operaci칩n queda listo hasta que 칠sta se complete.",
      "El proceso que solicita una operaci칩n queda ejecuci?n hasta que 칠sta se complete.",
      "El hebra que solicita una operaci칩n queda bloqueado hasta que 칠sta se complete."
    ],
    "correctIndex": 0
  },
  {
    "q": "Un enlace blando es",
    "options": [
      "Que un archivo contenga la ruta completa de otro",
      "El primer par?metro es la direcci?n del buffer en memoria.",
      "El tercer par?metro indica el n?mero de bytes a leer o escribir.",
      "Un enlace duro crea un nuevo inodo independiente."
    ],
    "correctIndex": 0
  },
  {
    "q": "Un enlace blando es",
    "options": [
      "Un archivo que contiene la ruta de otro",
      "El primer par?metro es la direcci?n del buffer en memoria.",
      "El tercer par?metro indica el n?mero de bytes a leer o escribir.",
      "Un enlace duro crea un nuevo inodo independiente."
    ],
    "correctIndex": 0
  },
  {
    "q": "En S_ISDIR(m)",
    "options": [
      "M corresponde al modo del archivo a comprobar",
      "Depende de la configuraci?n del sistema.",
      "Se realiza ?nicamente en modo usuario.",
      "Solo ocurre cuando el proceso finaliza."
    ],
    "correctIndex": 0
  },
  {
    "q": "Cuando se crea un nuevo proceso en los sistemas Unix/Linux",
    "options": [
      "Su tabla de archivos abiertos contendr치 enlaces a inodo con bloques vac칤os",
      "Su tabla de archivos abiertos contendr치 enlaces a bloque de datos con bloques vac칤os",
      "Se almacena ?nicamente en los registros generales del procesador.",
      "Permanece siempre en memoria secundaria aunque el proceso est? activo."
    ],
    "correctIndex": 0
  },
  {
    "q": "Cuando se crea un nuevo proceso en los sistemas Unix/Linux",
    "options": [
      "Su tabla de archivos abiertos contendr치 como m칤nimo 3 entradas",
      "Su tabla de archivos abiertos contendr치 como m칤nimo 2 entradas",
      "Su tabla de archivos abiertos contendr치 como m칤nimo 4 entradas",
      "Su tabla de archivos abiertos contendr치 como m칤nimo 5 entradas"
    ],
    "correctIndex": 0
  },
  {
    "q": "En los sistemas de archivos basados en inodos",
    "options": [
      "Crear un enlace duro a un archivo es equivalente a crear un nuevo nombre de archivo",
      "Crear un enlace blando a un archivo es equivalente a crear un nuevo nombre de archivo",
      "El primer par?metro es la direcci?n del buffer en memoria.",
      "El tercer par?metro indica el n?mero de bytes a leer o escribir."
    ],
    "correctIndex": 0
  },
  {
    "q": "En los sistemas de archivos basados en inodos:",
    "options": [
      "Un bloque referenciado desde otro puede contener datos o direcciones a otros bloques",
      "El primer par?metro es la direcci?n del buffer en memoria.",
      "El tercer par?metro indica el n?mero de bytes a leer o escribir.",
      "Un enlace duro crea un nuevo inodo independiente."
    ],
    "correctIndex": 0
  },
  {
    "q": "Ninguna de las opciones es correcta.",
    "options": [
      "Crear un enlace duro a un archivo da lugar a un nuevo inodo.",
      "Crear un enlace duro a un archivo da lugar a un nuevo bloque de datos.",
      "Crear un enlace blando a un archivo da lugar a un nuevo inodo.",
      "Depende de la configuraci?n del sistema."
    ],
    "correctIndex": 0
  },
  {
    "q": "En los sistemas de archivos basados en inodos",
    "options": [
      "La informaci칩n contenida en un bloque puede tener varios nombres",
      "El primer par?metro es la direcci?n del buffer en memoria.",
      "El tercer par?metro indica el n?mero de bytes a leer o escribir.",
      "Un enlace duro crea un nuevo inodo independiente."
    ],
    "correctIndex": 0
  },
  {
    "q": "El primer par치metro de la llamada al sistema write",
    "options": [
      "Especifica la entrada en la tabla de archivos abiertos del archivo sobre el que se va a escribir",
      "El primer par?metro es la direcci?n del buffer en memoria.",
      "El tercer par?metro indica el n?mero de bytes a leer o escribir.",
      "Un enlace duro crea un nuevo inodo independiente."
    ],
    "correctIndex": 0
  },
  {
    "q": "El primer par치metro de la llamada al sistema read",
    "options": [
      "Especifica la entrada en tabla de archivos abiertos del archivo sobre el que se va a leer",
      "El primer par?metro es la direcci?n del buffer en memoria.",
      "El tercer par?metro indica el n?mero de bytes a leer o escribir.",
      "Un enlace duro crea un nuevo inodo independiente."
    ],
    "correctIndex": 0
  },
  {
    "q": "El segundo par치metro de la llamada al sistema read",
    "options": [
      "Especifica un buffer donde se almacenar치n los bytes le칤dos del archivo que indique el tercer par치metro",
      "El primer par?metro es la direcci?n del buffer en memoria.",
      "El tercer par?metro indica el n?mero de bytes a leer o escribir.",
      "Un enlace duro crea un nuevo inodo independiente."
    ],
    "correctIndex": 0
  },
  {
    "q": "El tercer par치metro de la llamada al sistema open",
    "options": [
      "S칩lo tiene sentido si el archivo indicado no existe.",
      "El primer par?metro es la direcci?n del buffer en memoria.",
      "El tercer par?metro indica el n?mero de bytes a leer o escribir.",
      "Un enlace duro crea un nuevo inodo independiente."
    ],
    "correctIndex": 0
  },
  {
    "q": "En la llamada readdir(p):",
    "options": [
      "Se obtiene un puntero a una estructura dirent.",
      "No se obtiene un puntero a una estructura dirent.",
      "El primer par?metro es la direcci?n del buffer en memoria.",
      "El tercer par?metro indica el n?mero de bytes a leer o escribir."
    ],
    "correctIndex": 0
  },
  {
    "q": "La llamada al sistema lseek(4, 0, SEEK_SET)",
    "options": [
      "Sit칰a el puntero al principio del segundo archivo abierto desde el proceso.",
      "Sit칰a el puntero al principio del segundo archivo abierto desde el hebra.",
      "El primer par?metro es la direcci?n del buffer en memoria.",
      "El tercer par?metro indica el n?mero de bytes a leer o escribir."
    ],
    "correctIndex": 0
  },
  {
    "q": "La llamada al sistema lseek(3, 0, SEEK_END)",
    "options": [
      "Sit칰a el puntero al final del primer archivo abierto desde el proceso.",
      "Sit칰a el puntero al final del primer archivo abierto desde el hebra.",
      "El primer par?metro es la direcci?n del buffer en memoria.",
      "El tercer par?metro indica el n?mero de bytes a leer o escribir."
    ],
    "correctIndex": 0
  },
  {
    "q": "El controlador de un dispositivo:",
    "options": [
      "Es el hardware integrado en el dispositivo para su manejo.",
      "No es el hardware integrado en el dispositivo para su manejo.",
      "Depende de la configuraci?n del sistema.",
      "Se realiza ?nicamente en modo usuario."
    ],
    "correctIndex": 0
  }
];

    const letrasOpciones = ['a', 'b', 'c', 'd'];
    const GEMINI_API_KEY = 'AIzaSyCjegaPzmgrXLm1ttMvrmHetqwA2uhZfKY';
    const GEMINI_MODEL = 'gemini-1.5-flash';
    const STORAGE_KEY_PREFIX = 'ecso-quiz-state-v2:';
    const STORAGE_HISTORY_PREFIX = 'ecso-quiz-history-v1:';
    const STORAGE_LAST_KEY = 'ecso-quiz-last-dataset-v2';

    const DATASETS = { ec: preguntasEstructura, so: preguntasSistemasOperativos };

    let session = null;
    let questions = [];

    function getStorageKey(id) {
        return `${STORAGE_KEY_PREFIX}${id}`;
    }

    function getHistoryKey(id) {
        return `${STORAGE_HISTORY_PREFIX}${id}`;
    }

    function mulberry32(seed) {
        let t = seed >>> 0;
        return function() {
            t += 0x6D2B79F5;
            let r = Math.imul(t ^ (t >>> 15), 1 | t);
            r ^= r + Math.imul(r ^ (r >>> 7), 61 | r);
            return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
        };
    }

    function shuffle(array, rng) {
        const arr = array.slice();
        for (let i = arr.length - 1; i > 0; i--) {
            const j = Math.floor(rng() * (i + 1));
            [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        return arr;
    }

    function buildSession(datasetId) {
        const seed = Date.now();
        const rng = mulberry32(seed);
        const base = DATASETS[datasetId] || [];
        const order = shuffle([...Array(base.length).keys()], rng);
        const optionOrder = base.map((item) => shuffle([...Array(item.options.length).keys()], rng));
        session = {
            dataset: datasetId,
            seed,
            order,
            optionOrder,
            answers: {},
            currentIdx: 0,
            hits: 0,
            misses: 0,
            completed: false
        };
        saveState();
    }

    function loadSession(datasetId) {
        try {
            const raw = localStorage.getItem(getStorageKey(datasetId));
            if (!raw) return null;
            const parsed = JSON.parse(raw);
            if (!parsed || parsed.dataset !== datasetId) return null;
            if (!Array.isArray(parsed.order) || !Array.isArray(parsed.optionOrder)) return null;

            const base = DATASETS[datasetId] || [];
            if (parsed.order.length !== base.length) return null;
            if (parsed.optionOrder.length !== base.length) return null;
            const orderOk = parsed.optionOrder.every((ord, i) => Array.isArray(ord) && ord.length === base[i].options.length);
            if (!orderOk) return null;

            return parsed;
        } catch (e) {
            return null;
        }
    }

    function saveState() {
        if (!session) return;
        localStorage.setItem(getStorageKey(session.dataset), JSON.stringify(session));
        localStorage.setItem(STORAGE_LAST_KEY, session.dataset);
    }

    function updateStats() {
        document.getElementById('hits').innerText = session ? session.hits : 0;
        document.getElementById('miss').innerText = session ? session.misses : 0;
    }

    function getQuestionByIndex(displayIndex) {
        const baseIndex = session.order[displayIndex];
        const base = questions[baseIndex];
        const order = session.optionOrder[baseIndex];
        const options = order.map((i) => base.options[i]);
        const correctIndex = order.indexOf(base.correctIndex);
        const selectedIndex = session.answers[baseIndex];
        return { baseIndex, q: base.q, code: base.code, options, correctIndex, selectedIndex };
    }

    function escapeHtml(text) {
        const map = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;' };
        return String(text).replace(/[&<>"']/g, (m) => map[m]);
    }

    function renderQuestion(qData) {
        const questionEl = document.getElementById('question-text');
        if (qData.code) {
            const safeQ = escapeHtml(qData.q);
            const safeCode = escapeHtml(qData.code);
            questionEl.innerHTML = `${safeQ}<pre class="code-block">${safeCode}</pre>`;
            return;
        }
        questionEl.textContent = qData.q;
    }

    function renderOptions(qData) {
        const container = document.getElementById('options-container');
        container.innerHTML = '';
        qData.options.forEach((optText, i) => {
            const btn = document.createElement('button');
            btn.className = 'option';
            btn.innerText = `${letrasOpciones[i]}. ${optText}`;
            btn.onclick = () => selectAnswer(i);

            if (qData.selectedIndex !== undefined) {
                if (i === qData.correctIndex) {
                    btn.classList.add('correct');
                }
                if (i === qData.selectedIndex && qData.selectedIndex !== qData.correctIndex) {
                    btn.classList.add('wrong');
                }
            }

            container.appendChild(btn);
        });
    }

    function updateNavButtons() {
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        prevBtn.disabled = session.currentIdx === 0;
        if (session.currentIdx === session.order.length - 1) {
            nextBtn.textContent = 'Finalizar';
        } else {
            nextBtn.textContent = 'Siguiente';
        }
    }

    function showQuestion() {
        if (!session) return;
        const qData = getQuestionByIndex(session.currentIdx);
        document.getElementById('q-idx').innerText = session.currentIdx + 1;
        document.getElementById('q-total').innerText = session.order.length;
        renderQuestion(qData);
        resetHint();

        const topic = session.dataset === 'so' ? 'sistemas operativos' : 'estructura de computadores';
        const query = `quiero que expliques a un estudiante de ${topic} el siguiente concepto: "${qData.q}"`;
        document.getElementById('ia-btn').href = `https://www.google.com/search?q=${encodeURIComponent(query)}`;

        renderOptions(qData);
        updateNavButtons();
        updateStats();
    }

    function selectAnswer(selectedIndex) {
        const qData = getQuestionByIndex(session.currentIdx);
        const baseIndex = qData.baseIndex;
        const prev = session.answers[baseIndex];
        if (prev !== undefined) {
            if (prev === qData.correctIndex) {
                session.hits--;
            } else {
                session.misses--;
            }
        }
        session.answers[baseIndex] = selectedIndex;
        if (selectedIndex === qData.correctIndex) {
            session.hits++;
        } else {
            session.misses++;
        }
        saveState();
        showQuestion();
    }

    function startQuiz() {
        document.getElementById('setup').style.display = 'none';
        document.getElementById('quiz-game').style.display = 'block';
        showQuestion();
    }

    function startFromSelection(id) {
        const saved = loadSession(id);
        if (saved) {
            session = saved;
        } else {
            buildSession(id);
        }
        questions = DATASETS[id] || [];
        startQuiz();
    }

    function recordHistory() {
        if (!session) return;
        const key = getHistoryKey(session.dataset);
        const raw = localStorage.getItem(key);
        const history = raw ? JSON.parse(raw) : [];
        history.push({
            date: new Date().toISOString(),
            hits: session.hits,
            misses: session.misses,
            total: session.order.length
        });
        localStorage.setItem(key, JSON.stringify(history));
    }

    function nextQuestion() {
        if (!session) return;
        if (session.currentIdx < session.order.length - 1) {
            session.currentIdx++;
            saveState();
            showQuestion();
            return;
        }
        if (!session.completed) {
            session.completed = true;
            saveState();
            recordHistory();
            alert(`춰Test finalizado!
Aciertos: ${session.hits}
Fallos: ${session.misses}`);
        }
    }

    function prevQuestion() {
        if (!session) return;
        if (session.currentIdx > 0) {
            session.currentIdx--;
            saveState();
            showQuestion();
        }
    }

    function exitQuiz() {
        saveState();
        document.getElementById('quiz-game').style.display = 'none';
        document.getElementById('setup').style.display = 'block';
    }

    function restartQuiz() {
        if (!session) return;
        recordHistory();
        const datasetId = session.dataset;
        buildSession(datasetId);
        questions = DATASETS[datasetId] || [];
        startQuiz();
    }

    function resetHint() {
        const hintBox = document.getElementById('hint-box');
        hintBox.classList.remove('visible', 'loading');
        hintBox.textContent = '';
    }

    async function requestHint() {
        if (!session) return;
        const hintBox = document.getElementById('hint-box');
        hintBox.classList.remove('visible');
        hintBox.classList.add('loading');
        hintBox.textContent = 'Generando pista...';

        const qData = getQuestionByIndex(session.currentIdx);
        const promptLines = [
            'Eres un tutor. Da una pista breve (2-4 frases) basada en teor칤a.',
            'No digas la respuesta ni la letra correcta.',
            'Pregunta y opciones:',
            `Pregunta: ${qData.q}`,
            `Opciones: ${qData.options.map((opt, i) => `${letrasOpciones[i]}. ${opt}`).join(' | ')}`
        ];
        if (qData.code) {
            promptLines.splice(4, 0, `C칩digo:\n${qData.code}`);
        }

        const payload = {
            contents: [{
                role: 'user',
                parts: [{
                    text: promptLines.join('\n')
                }]
            }]
        };

        try {
            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent?key=${GEMINI_API_KEY}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            if (!response.ok) {
                throw new Error('No se pudo obtener la pista.');
            }
            const data = await response.json();
            const text = data?.candidates?.[0]?.content?.parts?.[0]?.text?.trim();
            hintBox.classList.remove('loading');
            hintBox.classList.add('visible');
            hintBox.textContent = text || 'No se pudo generar una pista.';
        } catch (err) {
            hintBox.classList.remove('loading');
            hintBox.classList.add('visible');
            hintBox.textContent = 'No se pudo generar una pista. Int칠ntalo de nuevo.';
        }
    }

    document.getElementById('load-ec').addEventListener('click', () => startFromSelection('ec'));
    document.getElementById('load-so').addEventListener('click', () => startFromSelection('so'));
    document.getElementById('exit-btn').addEventListener('click', exitQuiz);
    document.getElementById('restart-btn').addEventListener('click', restartQuiz);
    document.getElementById('hint-btn').addEventListener('click', requestHint);

    const storedLast = localStorage.getItem(STORAGE_LAST_KEY);
    if (storedLast && Array.isArray(DATASETS[storedLast]) && DATASETS[storedLast].length > 0) {
        const storedSession = loadSession(storedLast);
        if (storedSession) {
            session = storedSession;
            questions = DATASETS[storedLast] || [];
            startQuiz();
        }
    }

    window.addEventListener('beforeunload', saveState);
</script>


</body>
</html>
